{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize ESP-IDF v5.x project structure",
        "description": "Set up the complete ESP-IDF project with CMake configuration, component structure, and build system",
        "details": "Create root CMakeLists.txt with include($ENV{IDF_PATH}/tools/cmake/project.cmake), set up main component with entry point, configure sdkconfig.defaults with CONFIG_FREERTOS_HZ=1000, CONFIG_ESP_MAIN_TASK_STACK_SIZE=8192. Create idf_component.yml for dependency management.",
        "testStrategy": "Run idf.py build to verify successful compilation; check that all components are detected",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "updatedAt": "2025-10-15T01:55:00.892Z",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Configure partition table with LittleFS",
        "description": "Create custom partition table with dedicated LittleFS partition for pattern storage",
        "details": "Create partitions.csv with: nvs (0x9000, 24KB), otadata (0xF000, 8KB), app0 (0x11000, 1.5MB), app1 (0x181000, 1.5MB), prismfs data 0x82 (0x2F1000, 1MB). Set CONFIG_PARTITION_TABLE_CUSTOM=y in sdkconfig.defaults.",
        "testStrategy": "Run idf.py partition-table to verify partition layout; ensure prismfs partition is correctly sized at 1MB",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-15T01:55:17.454Z"
      },
      {
        "id": 3,
        "title": "Add LittleFS managed component",
        "description": "Integrate joltwallet/littlefs as managed component using ESP-IDF Component Manager",
        "details": "Add to idf_component.yml: dependencies: joltwallet/littlefs: '^1.20.1'. Run idf.py reconfigure to fetch component. Verify component downloaded to managed_components directory.",
        "testStrategy": "Check managed_components/joltwallet__littlefs exists; verify CMake finds the component",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-15T01:55:47.291Z"
      },
      {
        "id": 4,
        "title": "Implement core filesystem operations (prism_fs)",
        "description": "Create filesystem abstraction layer with LittleFS mounting, atomic operations, and index management",
        "details": "Implement prism_fs_init() with esp_vfs_littlefs_register(), format_if_mount_failed=true. Create atomic commit pattern: write to .tmp file, fsync, rename. Implement index operations using cJSON for metadata storage at /prism/.index.json.",
        "testStrategy": "Unit test: mount/unmount cycle, create/rename/delete file operations, verify atomic rename works correctly",
        "priority": "high",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement hash functions (prism_hash)",
        "description": "Create CRC32 and SHA256 implementations using ESP32 ROM functions and mbedTLS",
        "details": "CRC32: Use esp_rom_crc32_le() from ROM. SHA256: Use mbedtls_sha256_context with proper init/update/finish pattern. Create hex conversion utility. Add streaming hash support for large files.",
        "testStrategy": "Verify against NIST test vectors; test streaming vs single-shot hashing produces same results",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create error code system (prism_errors)",
        "description": "Define comprehensive error codes with HTTP status mapping",
        "details": "Define prism_error_t enum with PRISM_OK, PRISM_ERR_BAD_REQUEST, etc. Create error_to_http_status() mapping function. Use ESP_ERROR_CHECK_WITHOUT_ABORT for non-critical errors.",
        "testStrategy": "Verify each error code maps to correct HTTP status; test error propagation through call stack",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement binary file format parser for .prism files",
        "description": "Create .prism file header validation and TLV record parser with bounds checking for the .prism format",
        "details": "Validate .prism format magic bytes 'PRISM\\x00\\x00\\x00', version check, CRC32 header verification. Implement safe TLV parser with: bounds checking, maximum length validation, safe memory allocation. Support record types 0x0001-0x0005. This handles the .prism format (device runtime format), not the .k1p legacy format.",
        "testStrategy": "Test with malformed headers, oversized TLV records, corrupted CRC32; verify parser rejects invalid files safely",
        "priority": "high",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement structural efficiency optimizations",
        "description": "Optimize .prism format size through structural efficiency: shared palettes, delta encoding, and hot cache",
        "details": "Focus on structure-first approach rather than algorithm compression. Implement: (1) Shared palette system - reuse color palettes across patterns to reduce duplication, (2) Delta encoding for timeline keyframes - store differences between frames instead of absolute values, (3) Hot cache for frequently used patterns - keep popular patterns in RAM. Consider Heatshrink/gzip compression as optional later enhancement, not primary strategy. Target: reduce typical pattern size by 40-60% through structural efficiency alone.",
        "testStrategy": "Create test patterns with repeated palettes and verify sharing reduces file size; test delta encoding produces correct playback; benchmark hot cache hit rates",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Generate self-signed certificate for HTTPS",
        "description": "Create and embed self-signed certificate for HTTPS server",
        "details": "Generate 2048-bit RSA certificate with: openssl req -x509 -newkey rsa:2048 -keyout server_key.pem -out server_cert.pem -days 365 -nodes. Embed as string literals in prism_http.c. Consider future certificate provisioning mechanism.",
        "testStrategy": "Verify certificate loads correctly; test HTTPS connection with curl -k; check certificate details with openssl x509",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Initialize HTTPS server (prism_http)",
        "description": "Set up esp_https_server with embedded certificate and basic configuration",
        "details": "Use httpd_ssl_config_t with HTTPD_SSL_CONFIG_DEFAULT(), set server_cert and server_key from embedded strings. Configure max_uri_handlers=20, max_open_sockets=7, stack_size=8192. Start server on port 443.",
        "testStrategy": "Server starts successfully; curl -k https://device-ip/ returns connection; check memory usage",
        "priority": "high",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement REST endpoint routing",
        "description": "Create URI handlers for all REST endpoints with proper HTTP methods",
        "details": "Register handlers: POST /api/patterns (upload), GET /api/patterns (list), DELETE /api/patterns/:id (delete), POST /api/play (play), POST /api/playlist (playlist), GET /api/status (status). Use httpd_register_uri_handler() for each.",
        "testStrategy": "Each endpoint responds with correct status code; test with curl for all HTTP methods",
        "priority": "high",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement streaming upload handler",
        "description": "Create multipart upload handler with progress tracking and SHA256 verification",
        "details": "Use httpd_req_recv() in chunks of 4KB. Write to temporary file in /prism/.upload/. Calculate SHA256 during upload. Verify against X-PRISM-SHA256 header. Atomic rename on success. Send progress via WebSocket if connected.",
        "testStrategy": "Upload 50KB file, verify SHA256 matches; test interrupted upload cleanup; verify atomic commit",
        "priority": "high",
        "dependencies": [
          "11",
          "4",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement pattern list endpoint",
        "description": "Create GET /api/patterns handler that returns JSON array of stored patterns",
        "details": "Read /prism/.index.json, parse with cJSON, build response array with: uuid, name, size, uploadTime, duration. Set Content-Type: application/json. Handle empty index gracefully.",
        "testStrategy": "Upload 3 patterns, verify list returns all 3 with correct metadata; test with empty storage",
        "priority": "medium",
        "dependencies": [
          "11",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement pattern delete endpoint",
        "description": "Create DELETE handler with index cleanup",
        "details": "Parse UUID from URI path. Check file exists. Delete file with prism_fs_delete(). Update index to remove entry. Return 404 if not found, 200 on success.",
        "testStrategy": "Delete existing pattern, verify file removed and index updated; test deleting non-existent returns 404",
        "priority": "medium",
        "dependencies": [
          "11",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Add WebSocket endpoint (prism_ws)",
        "description": "Register WebSocket handler at /ws with upgrade support",
        "details": "Handle HTTP_GET for handshake with httpd_ws_respond_server_handshake(). Implement frame receiving with httpd_ws_recv_frame(). Support both text and binary frames. Maintain client connection list.",
        "testStrategy": "Test WebSocket handshake with wscat; send/receive text messages; verify binary frame support",
        "priority": "high",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement WebSocket message parser",
        "description": "Create JSON message parser and command router for WebSocket",
        "details": "Parse incoming JSON with cJSON. Route by 'type' field: set_param, play, pause, stop, get_status, subscribe. Validate message format. Send error responses for invalid messages.",
        "testStrategy": "Send various JSON commands, verify correct routing; test malformed JSON handling",
        "priority": "high",
        "dependencies": [
          "15"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement WebSocket client management",
        "description": "Track connected clients and enable broadcasting",
        "details": "Maintain array of client file descriptors (max 5). Add clients on connection, remove on disconnect. Implement broadcast function for events. Use httpd_ws_send_frame_async() for non-blocking sends.",
        "testStrategy": "Connect 3 clients, verify all receive broadcasts; test client limit enforcement",
        "priority": "medium",
        "dependencies": [
          "15",
          "16"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Create execution engine task (prism_exec)",
        "description": "Implement FreeRTOS task for pattern execution with command queue",
        "details": "Create task with 8KB stack, priority tskIDLE_PRIORITY+5. Implement command queue (depth 16) for play/pause/stop commands. Main loop: check queue, update timeline, generate frame, output to LEDs at 60 FPS.",
        "testStrategy": "Task starts and runs without stack overflow; verify 60 FPS timing; test command processing",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement timeline player",
        "description": "Create timeline-based pattern playback system",
        "details": "Track current position in milliseconds using esp_timer_get_time(). Interpolate between keyframes. Support looping with seamless wraparound. Calculate frame data for current timestamp.",
        "testStrategy": "Play 10-second pattern, verify correct position tracking; test loop wraparound",
        "priority": "high",
        "dependencies": [
          "18"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Implement curve interpolation",
        "description": "Add smooth interpolation between pattern keyframes",
        "details": "Support linear, ease-in, ease-out, ease-in-out curves. Use fixed-point math for efficiency. Implement cubic bezier for smooth transitions. Cache calculated values where possible.",
        "testStrategy": "Verify interpolation produces smooth values; test all curve types; benchmark performance",
        "priority": "medium",
        "dependencies": [
          "19"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement palette manager",
        "description": "Create color palette system for pattern rendering",
        "details": "Load palette from pattern file TLV record. Support up to 256 colors. Implement HSV to RGB conversion. Add color mixing and blending functions.",
        "testStrategy": "Load palette from test pattern; verify color conversions; test blending accuracy",
        "priority": "medium",
        "dependencies": [
          "19",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Implement live parameter system",
        "description": "Add real-time parameter modulation via WebSocket",
        "details": "Support parameters: intensity, speed, hue_shift, saturation. Store in shared structure with mutex protection. Apply modulation during frame generation. Send updates to execution engine via queue.",
        "testStrategy": "Change parameters via WebSocket, verify immediate effect; test thread safety",
        "priority": "medium",
        "dependencies": [
          "18",
          "16"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement playlist manager (prism_playlist)",
        "description": "Create sequential playlist playback system",
        "details": "Store playlist as array of UUIDs. Track current index. Implement next/previous navigation. Auto-advance on pattern completion. Support shuffle and repeat modes.",
        "testStrategy": "Create 3-item playlist, verify sequential playback; test shuffle mode randomness",
        "priority": "medium",
        "dependencies": [
          "18",
          "19"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Implement play command endpoint",
        "description": "Create POST /api/play handler for pattern playback",
        "details": "Parse JSON body for uuid, start_ms, loop parameters. Send command to execution engine via queue. Return immediate response. Update playback status.",
        "testStrategy": "Start playback via API, verify pattern plays; test with various start positions",
        "priority": "high",
        "dependencies": [
          "11",
          "18"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement status endpoint",
        "description": "Create GET /api/status with comprehensive system information",
        "details": "Return JSON with: playback state, current pattern, position, loop status, live parameters, storage usage, system uptime. Calculate storage from esp_littlefs_info().",
        "testStrategy": "Query status during playback, verify all fields present and accurate",
        "priority": "medium",
        "dependencies": [
          "11",
          "18",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Add mDNS service discovery",
        "description": "Implement zero-configuration discovery with mDNS",
        "details": "Initialize mDNS with mdns_init(). Set hostname 'prism-k1'. Advertise _https._tcp service on port 443. Add TXT records with version, capabilities.",
        "testStrategy": "Verify device appears in mDNS browser; test discovery from multiple clients",
        "priority": "low",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement rate limiting",
        "description": "Add upload rate limiting to prevent abuse",
        "details": "Track requests per IP using hash table. Limit to 10 uploads per minute. Return 429 Too Many Requests when exceeded. Reset counters every minute using timer.",
        "testStrategy": "Send 11 rapid uploads, verify 11th returns 429; test counter reset after timeout",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement concurrent upload limit",
        "description": "Restrict simultaneous uploads to prevent resource exhaustion",
        "details": "Use semaphore with count of 2. Take semaphore at upload start, release on completion/error. Return 503 Service Unavailable when limit reached.",
        "testStrategy": "Start 3 concurrent uploads, verify 3rd returns 503; test semaphore release on error",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Add filesystem reconciliation",
        "description": "Implement index rebuild on boot to handle corruption",
        "details": "On startup, scan /prism directory for .prism files. For each file: validate header, extract metadata, rebuild index entry. Remove orphaned temp files from .upload directory.",
        "testStrategy": "Corrupt index, reboot, verify index rebuilt correctly; test orphan cleanup",
        "priority": "medium",
        "dependencies": [
          "4",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement power-loss recovery",
        "description": "Add mechanisms to handle power loss during operations",
        "details": "Use journaling for critical operations. Implement two-phase commit for uploads. Add recovery markers in NVS. Clean incomplete operations on boot.",
        "testStrategy": "Simulate power loss during upload (unit test), verify cleanup on restart",
        "priority": "medium",
        "dependencies": [
          "4",
          "29"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Create unit tests for core modules",
        "description": "Comprehensive unit tests for hash, TLV parser, and filesystem",
        "details": "Test CRC32/SHA256 with NIST vectors. Test TLV parser with malformed data. Test filesystem atomic operations. Use Unity test framework. Run on host with ESP-IDF simulator.",
        "testStrategy": "All unit tests pass; achieve >80% code coverage for core modules",
        "priority": "high",
        "dependencies": [
          "5",
          "7",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Create integration tests",
        "description": "End-to-end tests for upload, playback, and WebSocket flows",
        "details": "Write shell scripts using curl and wscat. Test full upload flow with verification. Test pattern playback via API. Test WebSocket parameter updates. Include negative test cases.",
        "testStrategy": "All integration tests pass; test on actual hardware with network",
        "priority": "medium",
        "dependencies": [
          "24",
          "12",
          "16"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement memory profiling",
        "description": "Add heap monitoring and leak detection",
        "details": "Use esp_get_free_heap_size() monitoring. Track heap before/after operations. Use heap_caps_check_integrity_all() for corruption detection. Log warnings when heap drops below threshold.",
        "testStrategy": "Run stress test for 1 hour, verify no memory leaks; heap remains stable",
        "priority": "medium",
        "dependencies": [
          "31",
          "32"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Performance optimization",
        "description": "Optimize hot paths and critical sections",
        "details": "Profile with esp_timer functions. Optimize frame generation loop. Use DMA for LED output. Cache frequently accessed data. Reduce memory allocations in hot paths.",
        "testStrategy": "Achieve 60 FPS frame generation; <100ms play command latency; >500KB/s upload speed",
        "priority": "medium",
        "dependencies": [
          "19",
          "20",
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Create comprehensive documentation",
        "description": "Write README, API docs, and integration guide",
        "details": "Document all REST endpoints with examples. Create WebSocket protocol specification. Write integration guide for clients. Include troubleshooting section. Add configuration guide.",
        "testStrategy": "Documentation reviewed and validated; all examples tested and working",
        "priority": "low",
        "dependencies": [
          "32"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Create walking skeleton WebSocket MVP",
        "description": "Build minimal end-to-end proof: WebSocket upload, LittleFS storage, immediate playback",
        "details": "Create single main.cpp with: esp_http_server WebSocket at /ws, PUT_BEGIN/PUT_DATA/PUT_END protocol, write to LittleFS temp file, atomic rename on completion, PLAY command. Skip complex validation, just prove flow works. Use their provided code as base.",
        "testStrategy": "Upload 10KB test pattern via wscat, verify file stored, PLAY command returns success",
        "priority": "high",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Implement dual upload protocol support",
        "description": "Support both HTTP chunked uploads AND WebSocket uploads for flexibility",
        "details": "Keep HTTP POST /api/patterns for compatibility, add WebSocket upload as alternative. Share same storage backend. This gives clients choice of protocol based on their needs.",
        "testStrategy": "Upload same file via both protocols, verify identical storage results",
        "priority": "medium",
        "dependencies": [
          "12",
          "36"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Create Tauri 2 desktop app scaffold",
        "description": "Set up Tauri 2 app with Rust backend and React frontend",
        "details": "Initialize Tauri 2 project, add tokio-tungstenite for WebSocket client, mdns-sd for discovery, basic React UI with device picker and upload button. Start with their provided skeleton code.",
        "testStrategy": "App launches, discovers ESP32 device via mDNS, connects via WebSocket",
        "priority": "medium",
        "dependencies": [
          "36"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Implement Three.js LED preview",
        "description": "Create 3D preview with 320 LEDs and bloom effect",
        "details": "Use Three.js InstancedMesh for 320 LEDs on edges, MeshPhysicalMaterial with transmission for light guide plate, UnrealBloomPass for glow effect. Implement updateLEDs(rgb[]) API. Use their K1Preview class as base.",
        "testStrategy": "Preview renders at 60 FPS, LEDs update in real-time with color data",
        "priority": "medium",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Create .prism format compiler",
        "description": "Build pattern format compiler in Rust that outputs .prism files",
        "details": "Implement .prism v1 format: 32-byte header with magic 'PRISM\\x00\\x00\\x00', version, duration, CRC32. TLV body with timeline and metadata sections. Focus on structural efficiency first (shared palettes, delta encoding). Start uncompressed, structural optimizations reduce size naturally. This is the device runtime format, replacing legacy .k1p.",
        "testStrategy": "Compile test pattern to .prism, verify header structure, CRC32 validates on device, confirm structural optimizations reduce file size",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Implement timeline editor UI (primary creation mode)",
        "description": "Create timeline interface with drag/drop clips - available but not forced on users initially",
        "details": "Single track timeline, add/move/delete clips, snap to grid, basic undo/redo. Use React with canvas or existing timeline library. Timeline editor is the PRIMARY creation mode, but users can also browse and use templates without opening the editor. Focus on minimum viable editor that works alongside template library. Compile output to .prism format.",
        "testStrategy": "Create 3-clip timeline, compile to .prism, play on device; verify users can use app without opening timeline editor",
        "priority": "high",
        "dependencies": [
          "39",
          "40"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Add device discovery UI",
        "description": "Create device picker with mDNS discovery and manual IP fallback",
        "details": "List discovered devices from mDNS _k1prism._tcp, show connection status, allow manual IP entry, persist last connected device. Handle connection failures gracefully.",
        "testStrategy": "Discover device on network, connect, disconnect, reconnect successfully",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Create monorepo structure",
        "description": "Organize code into monorepo with clear separation",
        "details": "Structure: apps/studio/ (Tauri), firmware/ (ESP-IDF), libs/pattern/ (shared Rust), specs/ (documentation). Set up workspace Cargo.toml, shared dependencies, cross-compilation scripts.",
        "testStrategy": "All components build independently, shared libs link correctly",
        "priority": "low",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Implement pattern storage UI",
        "description": "Show stored patterns on device with management controls",
        "details": "List patterns with sizes, show storage usage bar, delete patterns, reorder for playlist. Use their LIST/DELETE WebSocket commands.",
        "testStrategy": "List shows all patterns, delete removes from device, storage bar accurate",
        "priority": "medium",
        "dependencies": [
          "42"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Add real-time parameter control",
        "description": "Implement live parameter updates via WebSocket",
        "details": "Send SET_PARAM commands for brightness, speed, hue shift. Update preview and device simultaneously. Use binary frames for efficiency if needed.",
        "testStrategy": "Adjust parameter in UI, see immediate change on device and preview",
        "priority": "low",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Design template system architecture",
        "description": "Define structure for template library system supporting 15-20 curated templates",
        "details": "Design template metadata schema (name, description, duration, category, preview thumbnail, parameters). Define storage structure: embedded in desktop app vs remote CDN. Plan template categories: Ambient, Energy, Minimal, Rhythmic, etc. Define how templates relate to timeline editor (templates can be starting points or standalone). Target: 60-second out-of-box experience with zero creation required.",
        "testStrategy": "Document template schema; validate it supports all required metadata; get user approval on categories",
        "priority": "high",
        "dependencies": [
          "40",
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Implement template library UI",
        "description": "Create browsable template gallery with preview and one-click deployment",
        "details": "Grid/list view of templates with thumbnails, category filters, search. Preview button shows Three.js visualization. Deploy button compiles template to .prism and uploads to device. Allow marking templates as favorites. Templates should feel like Netflix/Spotify browsing experience - simple, visual, immediate.",
        "testStrategy": "Browse templates, preview 3 different templates, deploy one to device, verify it plays correctly",
        "priority": "high",
        "dependencies": [
          "46",
          "39"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Create 5 foundational templates (Phase 1)",
        "description": "Design and implement first 5 core templates covering major visual styles",
        "details": "Create templates: (1) Ambient Pulse - slow breathing effect, (2) Energy Wave - fast rhythmic motion, (3) Minimal Fade - subtle color transitions, (4) Strobe Burst - high-energy flashing, (5) Color Cycle - smooth rainbow rotation. Each template should be 10-30 seconds, use timeline format, showcase different effect types. Include preview thumbnails and metadata.",
        "testStrategy": "Deploy each template, verify visual quality matches intent, ensure all compile to .prism correctly",
        "priority": "high",
        "dependencies": [
          "46",
          "40"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Create 10 diverse templates (Phase 2)",
        "description": "Expand template library with 10 more diverse patterns",
        "details": "Create templates covering: rhythmic patterns (3), ambient/chill (2), high-energy (2), experimental (2), holiday/themed (1). Ensure variety in speed, color palette, complexity. Each template should demonstrate different combinations of effects, palettes, and timing. Total library now 15 templates.",
        "testStrategy": "User testing: can new user find and deploy a template they like within 60 seconds? Verify visual diversity across all 15 templates",
        "priority": "high",
        "dependencies": [
          "48",
          "47"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Add 5 advanced templates (Phase 3)",
        "description": "Create final 5 templates showcasing advanced techniques",
        "details": "Create advanced templates: (1) Multi-layer composition, (2) Complex palette transitions, (3) Beat-reactive pattern, (4) Generative/evolving pattern, (5) Showcase/demo pattern (best of all techniques). These templates serve as inspiration for users learning timeline editor. Total library now 20 templates. Focus on 'wow factor' to demonstrate system capabilities.",
        "testStrategy": "Deploy advanced templates, verify performance on device, confirm they inspire users to explore timeline editor",
        "priority": "medium",
        "dependencies": [
          "49"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Implement template-to-timeline conversion",
        "description": "Allow users to open templates in timeline editor for customization",
        "details": "Add 'Edit Template' button that loads template into timeline editor. User can modify clips, timing, palettes, then save as custom pattern. This bridges gap between templates (easy) and timeline editor (powerful). Preserve template metadata when loading. Consider 'Save as Template' to let users share creations.",
        "testStrategy": "Open template in editor, modify it, save as custom pattern, deploy to device, verify changes applied",
        "priority": "medium",
        "dependencies": [
          "47",
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Add template update mechanism",
        "description": "Enable updating template library without app recompilation",
        "details": "Implement remote template manifest (JSON) that desktop app fetches on launch. Templates can be updated/added via CDN without app updates. Include version checking, local caching, and fallback to embedded templates if offline. Consider update notifications when new templates available.",
        "testStrategy": "Update remote manifest, restart app, verify new templates appear; test offline mode falls back to embedded templates",
        "priority": "low",
        "dependencies": [
          "47",
          "50"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Add node editor as experimental feature",
        "description": "Implement node-based composition editor as advanced/experimental mode",
        "details": "Node editor is FUTURE/EXPERIMENTAL feature, not part of primary workflow. Implement basic node graph UI for advanced users: effect nodes, palette nodes, parameter nodes, composition nodes. Should feel like Blender/TouchDesigner for LED patterns. Hide behind 'Advanced Mode' toggle or separate tab. Not required for 1.0 release - timeline editor is primary creation mode.",
        "testStrategy": "Create simple 2-node graph, compile to .prism, verify output matches timeline-created pattern",
        "priority": "low",
        "dependencies": [
          "41",
          "50"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Implement memory pool manager to prevent heap fragmentation",
        "description": "Create fixed-size memory pools at startup for all dynamic allocations to prevent heap fragmentation that causes device failure within 12-48 hours",
        "details": "Implement a memory pool manager in firmware/components/core/memory_pool.c that pre-allocates fixed-size pools during system initialization. Create three pool sizes: POOL_4KB (4096 bytes) for WebSocket frames (based on WS_BUFFER_SIZE=8192 in sdkconfig.defaults), POOL_1KB (1024 bytes) for HTTP headers and small buffers, and POOL_256B (256 bytes) for messages and control structures. Use heap_caps_malloc(size, MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT) during initialization to allocate pool memory. Implement pool structures with free lists using atomic operations (portENTER_CRITICAL/portEXIT_CRITICAL). Create prism_pool_alloc(size_t size) to return appropriate pool block, prism_pool_free(void *ptr) for returns. Add pool statistics tracking: allocations, frees, current usage, high water mark, and failed allocations. Initialize pools in system_init() before any component initialization. Replace all dynamic allocations after init with pool allocations. Add compile-time assertion to prevent malloc/free usage post-init using __wrap_malloc and __wrap_free linker wrapping. Pool sizes: 8 blocks of 4KB (32KB total), 16 blocks of 1KB (16KB total), 32 blocks of 256B (8KB total) = 56KB reserved heap.",
        "testStrategy": "Create unit tests to verify pool initialization allocates exactly 56KB from heap. Test allocation/free patterns: allocate all blocks, verify failure on N+1, free all, reallocate. Run stress test with rapid alloc/free cycles for 72 hours monitoring heap_caps_get_free_size() to verify zero fragmentation. Test WebSocket frame allocation uses 4KB pool. Verify malloc() calls after init trigger assertion failure. Monitor pool statistics during 48-hour runtime, verify no failed allocations under normal load. Use heap_caps_check_integrity_all() every hour to detect corruption. Benchmark allocation speed vs direct malloc (target <10% overhead).",
        "status": "pending",
        "dependencies": [
          1,
          33
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Create heap monitoring system with fragmentation detection",
        "description": "Implement comprehensive heap monitoring system that tracks memory health every second, detects fragmentation, and provides early warning for memory-related failures",
        "details": "Create a dedicated heap monitoring component in firmware/components/core/heap_monitor.c with header prism_heap_monitor.h. Implement heap_monitor_init() to initialize monitoring structures and start a FreeRTOS task with 3KB stack at priority tskIDLE_PRIORITY+2. The monitoring task should run every second using vTaskDelayUntil() for precise timing. Track metrics: current free heap via esp_get_free_heap_size(), minimum free heap via esp_get_minimum_free_heap_size(), largest contiguous block via heap_caps_get_largest_free_block(MALLOC_CAP_8BIT), and calculate fragmentation percentage as ((free_heap - largest_block) * 100) / free_heap. Implement critical thresholds: HEAP_CRITICAL_MIN (50KB), HEAP_WARNING_MIN (75KB), LARGEST_BLOCK_MIN (20KB), FRAGMENTATION_WARNING (30%), FRAGMENTATION_CRITICAL (50%). Create alert system using ESP_LOGW for warnings and ESP_LOGE for critical states. Track all task stack high-water marks by iterating through tasks using uxTaskGetSystemState() and calling uxTaskGetStackHighWaterMark() for each task handle. Log stack usage for tasks approaching limits (<512 bytes remaining). Store metrics in circular buffer (last 60 samples) for trend analysis. Implement heap_monitor_get_stats() API to return current metrics structure. Add heap integrity checking using heap_caps_check_integrity_all() every 10 seconds in debug builds (CONFIG_HEAP_POISONING_LIGHT enabled in sdkconfig.defaults). Replace the basic heap_monitor_task in main.c with this comprehensive monitoring system. Add compile-time option CONFIG_HEAP_MONITOR_ENABLE to sdkconfig.defaults. Include performance counter to track time spent in monitoring (target <1ms per cycle). Create heap_monitor_dump_stats() to output detailed report including per-task stack usage, heap trends, and fragmentation history. Integrate with system error handler to dump heap stats on crash.",
        "testStrategy": "Verify monitoring task starts and runs without impacting system performance (<1ms overhead). Test threshold detection by allocating/freeing memory to trigger each alert level. Confirm fragmentation calculation by creating deliberate fragmentation pattern (allocate mixed sizes, free alternating blocks) and verify percentage matches expected value. Test stack monitoring by creating test task with known stack size, fill stack with pattern, verify high-water mark detection. Run 72-hour stability test monitoring all metrics, verify no memory leaks in monitor itself. Test alert system triggers at exact thresholds (50KB, 20KB largest block). Verify circular buffer correctly stores 60 samples and wraps properly. Test heap integrity checking detects deliberate corruption in debug build. Benchmark monitoring overhead stays under 1ms per second. Verify dump_stats output includes all tracked metrics in readable format. Test integration with existing heap_monitor_task replacement in main.c.",
        "status": "pending",
        "dependencies": [
          1,
          18
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "Implement bounds checking utilities for all input validation",
        "description": "Create comprehensive safe buffer handling utilities with macros for secure memory operations, preventing buffer overflows and crashes through rigorous validation of all size parameters before operations.",
        "details": "Implement prism_secure.h/c in firmware/components/core/ with critical safety utilities:\n\n1. Safe memory operations:\n- SAFE_MEMCPY(dst, src, size, max_size) - validates size <= max_size before memcpy\n- SAFE_STRNCPY(dst, src, max_len) - ensures null termination, prevents overflow\n- SAFE_MEMMOVE(dst, src, size, max_size) - bounds-checked memmove\n- BOUNDS_CHECK(ptr, offset, size, max) - validates pointer arithmetic safety\n\n2. WebSocket frame validation (per websocket_protocol.md):\n- ws_validate_frame_length(length) - check against 8192 byte maximum\n- ws_validate_tlv_bounds(type, length, payload_ptr, frame_end) - ensure TLV doesn't exceed frame\n- ws_validate_session_id(id) - prevent integer overflow in session tracking\n\n3. Pattern file validation:\n- pattern_validate_header_size(size) - check header bounds before parsing\n- pattern_validate_chunk_offset(offset, chunk_size, file_size) - prevent read beyond EOF\n- pattern_validate_filename(name, max_len) - sanitize and length check\n\n4. Array access safety:\n- SAFE_ARRAY_INDEX(array, index, size) - returns NULL if out of bounds\n- SAFE_BUFFER_APPEND(buf, data, len, buf_size) - atomic append with overflow check\n- CIRCULAR_INDEX(index, size) - safe wraparound for ring buffers\n\n5. String operations:\n- safe_strlen(str, max_len) - bounded string length\n- safe_strcmp(s1, s2, max_len) - bounded comparison\n- safe_atoi(str, result, min, max) - parse with range validation\n\n6. Integer overflow protection:\n- SAFE_ADD(a, b, result) - check for overflow before addition\n- SAFE_MUL(a, b, result) - check for multiplication overflow\n- SIZE_T_MAX_CHECK(size) - validate against platform limits\n\nAll macros should use static inline functions for type safety and include ESP_LOGE logging on violations. Functions return esp_err_t with ESP_ERR_INVALID_SIZE on bounds violations. Critical functions marked IRAM_ATTR for interrupt context safety.",
        "testStrategy": "Create test_bounds_checking.c with comprehensive unit tests:\n1. Test each macro with valid inputs, boundary cases, and overflow attempts\n2. Verify WebSocket frames >8192 bytes are rejected\n3. Test TLV parsing with malformed lengths that exceed frame boundaries\n4. Simulate buffer overflow attempts with oversized memcpy operations\n5. Verify all safety checks log errors via ESP_LOGE\n6. Test circular buffer wraparound with CIRCULAR_INDEX\n7. Verify integer overflow detection in SAFE_ADD/SAFE_MUL\n8. Run stress test with fuzzer generating random invalid inputs\n9. Memory leak check with heap_caps_check_integrity_all()\n10. Verify no performance regression (<1% overhead) in critical paths",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-15T01:55:47.291Z",
      "taskCount": 53,
      "completedCount": 3,
      "tags": [
        "master"
      ],
      "created": "2025-10-15T02:03:04.757Z",
      "description": "Tasks for master context",
      "updated": "2025-10-15T04:31:19.772Z"
    }
  }
}