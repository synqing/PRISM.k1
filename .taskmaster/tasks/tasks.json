{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize ESP-IDF v5.x project structure",
        "description": "Set up the complete ESP-IDF project with CMake configuration, component structure, and build system",
        "details": "Create root CMakeLists.txt with include($ENV{IDF_PATH}/tools/cmake/project.cmake), set up main component with entry point, configure sdkconfig.defaults with CONFIG_FREERTOS_HZ=1000, CONFIG_ESP_MAIN_TASK_STACK_SIZE=8192. Create idf_component.yml for dependency management.",
        "testStrategy": "Run idf.py build to verify successful compilation; check that all components are detected",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "updatedAt": "2025-10-15T01:55:00.892Z",
        "subtasks": []
      },
      {
        "id": "2",
        "title": "Configure partition table with LittleFS",
        "description": "Create custom partition table with dedicated LittleFS partition for pattern storage",
        "details": "Create partitions.csv with: nvs (0x9000, 24KB), otadata (0xF000, 8KB), app0 (0x11000, 1.5MB), app1 (0x181000, 1.5MB), prismfs data 0x82 (0x2F1000, 1MB). Set CONFIG_PARTITION_TABLE_CUSTOM=y in sdkconfig.defaults.",
        "testStrategy": "Run idf.py partition-table to verify partition layout; ensure prismfs partition is correctly sized at 1MB",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-15T01:55:17.454Z"
      },
      {
        "id": "3",
        "title": "Add LittleFS managed component",
        "description": "Integrate joltwallet/littlefs as managed component using ESP-IDF Component Manager",
        "details": "Add to idf_component.yml: dependencies: joltwallet/littlefs: '^1.20.1'. Run idf.py reconfigure to fetch component. Verify component downloaded to managed_components directory.",
        "testStrategy": "Check managed_components/joltwallet__littlefs exists; verify CMake finds the component",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "Implement core filesystem operations (prism_fs)",
        "description": "Create filesystem abstraction layer with LittleFS mounting, atomic operations, and index management",
        "details": "Implement prism_fs_init() with esp_vfs_littlefs_register(), format_if_mount_failed=true. Create atomic commit pattern: write to .tmp file, fsync, rename. Implement index operations using cJSON for metadata storage at /prism/.index.json.",
        "testStrategy": "Unit test: mount/unmount cycle, create/rename/delete file operations, verify atomic rename works correctly",
        "priority": "high",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Implement hash functions (prism_hash)",
        "description": "Create CRC32 and SHA256 implementations using ESP32 ROM functions and mbedTLS",
        "details": "CRC32: Use esp_rom_crc32_le() from ROM. SHA256: Use mbedtls_sha256_context with proper init/update/finish pattern. Create hex conversion utility. Add streaming hash support for large files.",
        "testStrategy": "Verify against NIST test vectors; test streaming vs single-shot hashing produces same results",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Create error code system (prism_errors)",
        "description": "Define comprehensive error codes with HTTP status mapping",
        "details": "Define prism_error_t enum with PRISM_OK, PRISM_ERR_BAD_REQUEST, etc. Create error_to_http_status() mapping function. Use ESP_ERROR_CHECK_WITHOUT_ABORT for non-critical errors.",
        "testStrategy": "Verify each error code maps to correct HTTP status; test error propagation through call stack",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Implement binary file format parser for .prism files",
        "description": "Create .prism file header validation and TLV record parser with bounds checking for the .prism format",
        "details": "Validate .prism format magic bytes 'PRISM\\x00\\x00\\x00', version check, CRC32 header verification. Implement safe TLV parser with: bounds checking, maximum length validation, safe memory allocation. Support record types 0x0001-0x0005. This handles the .prism format (device runtime format), not the .k1p legacy format.",
        "testStrategy": "Test with malformed headers, oversized TLV records, corrupted CRC32; verify parser rejects invalid files safely",
        "priority": "high",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Implement structural efficiency optimizations",
        "description": "Optimize .prism format size through structural efficiency: shared palettes, delta encoding, and hot cache",
        "details": "Focus on structure-first approach rather than algorithm compression. Implement: (1) Shared palette system - reuse color palettes across patterns to reduce duplication, (2) Delta encoding for timeline keyframes - store differences between frames instead of absolute values, (3) Hot cache for frequently used patterns - keep popular patterns in RAM. Consider Heatshrink/gzip compression as optional later enhancement, not primary strategy. Target: reduce typical pattern size by 40-60% through structural efficiency alone.",
        "testStrategy": "Create test patterns with repeated palettes and verify sharing reduces file size; test delta encoding produces correct playback; benchmark hot cache hit rates",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Generate self-signed certificate for HTTPS",
        "description": "Create and embed self-signed certificate for HTTPS server",
        "details": "Generate 2048-bit RSA certificate with: openssl req -x509 -newkey rsa:2048 -keyout server_key.pem -out server_cert.pem -days 365 -nodes. Embed as string literals in prism_http.c. Consider future certificate provisioning mechanism.",
        "testStrategy": "Verify certificate loads correctly; test HTTPS connection with curl -k; check certificate details with openssl x509",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Initialize HTTPS server (prism_http)",
        "description": "Set up esp_https_server with embedded certificate and basic configuration",
        "details": "Use httpd_ssl_config_t with HTTPD_SSL_CONFIG_DEFAULT(), set server_cert and server_key from embedded strings. Configure max_uri_handlers=20, max_open_sockets=7, stack_size=8192. Start server on port 443.",
        "testStrategy": "Server starts successfully; curl -k https://device-ip/ returns connection; check memory usage",
        "priority": "high",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "11",
        "title": "Implement REST endpoint routing",
        "description": "Create URI handlers for all REST endpoints with proper HTTP methods",
        "details": "Register handlers: POST /api/patterns (upload), GET /api/patterns (list), DELETE /api/patterns/:id (delete), POST /api/play (play), POST /api/playlist (playlist), GET /api/status (status). Use httpd_register_uri_handler() for each.",
        "testStrategy": "Each endpoint responds with correct status code; test with curl for all HTTP methods",
        "priority": "high",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "12",
        "title": "Implement streaming upload handler",
        "description": "Create multipart upload handler with progress tracking and SHA256 verification",
        "details": "Use httpd_req_recv() in chunks of 4KB. Write to temporary file in /prism/.upload/. Calculate SHA256 during upload. Verify against X-PRISM-SHA256 header. Atomic rename on success. Send progress via WebSocket if connected.",
        "testStrategy": "Upload 50KB file, verify SHA256 matches; test interrupted upload cleanup; verify atomic commit",
        "priority": "high",
        "dependencies": [
          "11",
          "4",
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "13",
        "title": "Implement pattern list endpoint",
        "description": "Create GET /api/patterns handler that returns JSON array of stored patterns",
        "details": "Read /prism/.index.json, parse with cJSON, build response array with: uuid, name, size, uploadTime, duration. Set Content-Type: application/json. Handle empty index gracefully.",
        "testStrategy": "Upload 3 patterns, verify list returns all 3 with correct metadata; test with empty storage",
        "priority": "medium",
        "dependencies": [
          "11",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Implement pattern delete endpoint",
        "description": "Create DELETE handler with index cleanup",
        "details": "Parse UUID from URI path. Check file exists. Delete file with prism_fs_delete(). Update index to remove entry. Return 404 if not found, 200 on success.",
        "testStrategy": "Delete existing pattern, verify file removed and index updated; test deleting non-existent returns 404",
        "priority": "medium",
        "dependencies": [
          "11",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "Add WebSocket endpoint (prism_ws)",
        "description": "Register WebSocket handler at /ws with upgrade support",
        "details": "Handle HTTP_GET for handshake with httpd_ws_respond_server_handshake(). Implement frame receiving with httpd_ws_recv_frame(). Support both text and binary frames. Maintain client connection list.",
        "testStrategy": "Test WebSocket handshake with wscat; send/receive text messages; verify binary frame support",
        "priority": "high",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "16",
        "title": "Implement WebSocket message parser",
        "description": "Create JSON message parser and command router for WebSocket",
        "details": "Parse incoming JSON with cJSON. Route by 'type' field: set_param, play, pause, stop, get_status, subscribe. Validate message format. Send error responses for invalid messages.",
        "testStrategy": "Send various JSON commands, verify correct routing; test malformed JSON handling",
        "priority": "high",
        "dependencies": [
          "15"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "17",
        "title": "Implement WebSocket client management",
        "description": "Track connected clients and enable broadcasting",
        "details": "Maintain array of client file descriptors (max 5). Add clients on connection, remove on disconnect. Implement broadcast function for events. Use httpd_ws_send_frame_async() for non-blocking sends.",
        "testStrategy": "Connect 3 clients, verify all receive broadcasts; test client limit enforcement",
        "priority": "medium",
        "dependencies": [
          "15",
          "16"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "18",
        "title": "Create execution engine task (prism_exec)",
        "description": "Implement FreeRTOS task for pattern execution with command queue",
        "details": "Create task with 8KB stack, priority tskIDLE_PRIORITY+5. Implement command queue (depth 16) for play/pause/stop commands. Main loop: check queue, update timeline, generate frame, output to LEDs at 60 FPS.",
        "testStrategy": "Task starts and runs without stack overflow; verify 60 FPS timing; test command processing",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "19",
        "title": "Implement timeline player",
        "description": "Create timeline-based pattern playback system",
        "details": "Track current position in milliseconds using esp_timer_get_time(). Interpolate between keyframes. Support looping with seamless wraparound. Calculate frame data for current timestamp.",
        "testStrategy": "Play 10-second pattern, verify correct position tracking; test loop wraparound",
        "priority": "high",
        "dependencies": [
          "18"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "20",
        "title": "Implement curve interpolation",
        "description": "Add smooth interpolation between pattern keyframes",
        "details": "Support linear, ease-in, ease-out, ease-in-out curves. Use fixed-point math for efficiency. Implement cubic bezier for smooth transitions. Cache calculated values where possible.",
        "testStrategy": "Verify interpolation produces smooth values; test all curve types; benchmark performance",
        "priority": "medium",
        "dependencies": [
          "19"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "21",
        "title": "Implement palette manager",
        "description": "Create color palette system for pattern rendering",
        "details": "Load palette from pattern file TLV record. Support up to 256 colors. Implement HSV to RGB conversion. Add color mixing and blending functions.",
        "testStrategy": "Load palette from test pattern; verify color conversions; test blending accuracy",
        "priority": "medium",
        "dependencies": [
          "19",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "22",
        "title": "Implement live parameter system",
        "description": "Add real-time parameter modulation via WebSocket",
        "details": "Support parameters: intensity, speed, hue_shift, saturation. Store in shared structure with mutex protection. Apply modulation during frame generation. Send updates to execution engine via queue.",
        "testStrategy": "Change parameters via WebSocket, verify immediate effect; test thread safety",
        "priority": "medium",
        "dependencies": [
          "18",
          "16"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "23",
        "title": "Implement playlist manager (prism_playlist)",
        "description": "Create sequential playlist playback system",
        "details": "Store playlist as array of UUIDs. Track current index. Implement next/previous navigation. Auto-advance on pattern completion. Support shuffle and repeat modes.",
        "testStrategy": "Create 3-item playlist, verify sequential playback; test shuffle mode randomness",
        "priority": "medium",
        "dependencies": [
          "18",
          "19"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "24",
        "title": "Implement play command endpoint",
        "description": "Create POST /api/play handler for pattern playback",
        "details": "Parse JSON body for uuid, start_ms, loop parameters. Send command to execution engine via queue. Return immediate response. Update playback status.",
        "testStrategy": "Start playback via API, verify pattern plays; test with various start positions",
        "priority": "high",
        "dependencies": [
          "11",
          "18"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "25",
        "title": "Implement status endpoint",
        "description": "Create GET /api/status with comprehensive system information",
        "details": "Return JSON with: playback state, current pattern, position, loop status, live parameters, storage usage, system uptime. Calculate storage from esp_littlefs_info().",
        "testStrategy": "Query status during playback, verify all fields present and accurate",
        "priority": "medium",
        "dependencies": [
          "11",
          "18",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "26",
        "title": "Add mDNS service discovery",
        "description": "Implement zero-configuration discovery with mDNS",
        "details": "Initialize mDNS with mdns_init(). Set hostname 'prism-k1'. Advertise _https._tcp service on port 443. Add TXT records with version, capabilities.",
        "testStrategy": "Verify device appears in mDNS browser; test discovery from multiple clients",
        "priority": "low",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "27",
        "title": "Implement rate limiting",
        "description": "Add upload rate limiting to prevent abuse",
        "details": "Track requests per IP using hash table. Limit to 10 uploads per minute. Return 429 Too Many Requests when exceeded. Reset counters every minute using timer.",
        "testStrategy": "Send 11 rapid uploads, verify 11th returns 429; test counter reset after timeout",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "28",
        "title": "Implement concurrent upload limit",
        "description": "Restrict simultaneous uploads to prevent resource exhaustion",
        "details": "Use semaphore with count of 2. Take semaphore at upload start, release on completion/error. Return 503 Service Unavailable when limit reached.",
        "testStrategy": "Start 3 concurrent uploads, verify 3rd returns 503; test semaphore release on error",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "29",
        "title": "Add filesystem reconciliation",
        "description": "Implement index rebuild on boot to handle corruption",
        "details": "On startup, scan /prism directory for .prism files. For each file: validate header, extract metadata, rebuild index entry. Remove orphaned temp files from .upload directory.",
        "testStrategy": "Corrupt index, reboot, verify index rebuilt correctly; test orphan cleanup",
        "priority": "medium",
        "dependencies": [
          "4",
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "30",
        "title": "Implement power-loss recovery",
        "description": "Add mechanisms to handle power loss during operations",
        "details": "Use journaling for critical operations. Implement two-phase commit for uploads. Add recovery markers in NVS. Clean incomplete operations on boot.",
        "testStrategy": "Simulate power loss during upload (unit test), verify cleanup on restart",
        "priority": "medium",
        "dependencies": [
          "4",
          "29"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "31",
        "title": "Create unit tests for core modules",
        "description": "Comprehensive unit tests for hash, TLV parser, and filesystem",
        "details": "Test CRC32/SHA256 with NIST vectors. Test TLV parser with malformed data. Test filesystem atomic operations. Use Unity test framework. Run on host with ESP-IDF simulator.",
        "testStrategy": "All unit tests pass; achieve >80% code coverage for core modules",
        "priority": "high",
        "dependencies": [
          "5",
          "7",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "32",
        "title": "Create integration tests",
        "description": "End-to-end tests for upload, playback, and WebSocket flows",
        "details": "Write shell scripts using curl and wscat. Test full upload flow with verification. Test pattern playback via API. Test WebSocket parameter updates. Include negative test cases.",
        "testStrategy": "All integration tests pass; test on actual hardware with network",
        "priority": "medium",
        "dependencies": [
          "24",
          "12",
          "16"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "33",
        "title": "Implement memory profiling",
        "description": "Add heap monitoring and leak detection",
        "details": "Use esp_get_free_heap_size() monitoring. Track heap before/after operations. Use heap_caps_check_integrity_all() for corruption detection. Log warnings when heap drops below threshold.",
        "testStrategy": "Run stress test for 1 hour, verify no memory leaks; heap remains stable",
        "priority": "medium",
        "dependencies": [
          "31",
          "32"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "34",
        "title": "Performance optimization",
        "description": "Optimize hot paths and critical sections",
        "details": "Profile with esp_timer functions. Optimize frame generation loop. Use DMA for LED output. Cache frequently accessed data. Reduce memory allocations in hot paths.",
        "testStrategy": "Achieve 60 FPS frame generation; <100ms play command latency; >500KB/s upload speed",
        "priority": "medium",
        "dependencies": [
          "19",
          "20",
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "35",
        "title": "Create comprehensive documentation",
        "description": "Write README, API docs, and integration guide",
        "details": "Document all REST endpoints with examples. Create WebSocket protocol specification. Write integration guide for clients. Include troubleshooting section. Add configuration guide.",
        "testStrategy": "Documentation reviewed and validated; all examples tested and working",
        "priority": "low",
        "dependencies": [
          "32"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "36",
        "title": "Create walking skeleton WebSocket MVP",
        "description": "Build minimal end-to-end proof: WebSocket upload, LittleFS storage, immediate playback",
        "details": "Create single main.cpp with: esp_http_server WebSocket at /ws, PUT_BEGIN/PUT_DATA/PUT_END protocol, write to LittleFS temp file, atomic rename on completion, PLAY command. Skip complex validation, just prove flow works. Use their provided code as base.",
        "testStrategy": "Upload 10KB test pattern via wscat, verify file stored, PLAY command returns success",
        "priority": "high",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "37",
        "title": "Implement dual upload protocol support",
        "description": "Support both HTTP chunked uploads AND WebSocket uploads for flexibility",
        "details": "Keep HTTP POST /api/patterns for compatibility, add WebSocket upload as alternative. Share same storage backend. This gives clients choice of protocol based on their needs.",
        "testStrategy": "Upload same file via both protocols, verify identical storage results",
        "priority": "medium",
        "dependencies": [
          "12",
          "36"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "38",
        "title": "Create Tauri 2 desktop app scaffold",
        "description": "Set up Tauri 2 app with Rust backend and React frontend",
        "details": "Initialize Tauri 2 project, add tokio-tungstenite for WebSocket client, mdns-sd for discovery, basic React UI with device picker and upload button. Start with their provided skeleton code.",
        "testStrategy": "App launches, discovers ESP32 device via mDNS, connects via WebSocket",
        "priority": "medium",
        "dependencies": [
          "36"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "39",
        "title": "Implement Three.js LED preview",
        "description": "Create 3D preview with 320 LEDs and bloom effect",
        "details": "Use Three.js InstancedMesh for 320 LEDs on edges, MeshPhysicalMaterial with transmission for light guide plate, UnrealBloomPass for glow effect. Implement updateLEDs(rgb[]) API. Use their K1Preview class as base.",
        "testStrategy": "Preview renders at 60 FPS, LEDs update in real-time with color data",
        "priority": "medium",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "40",
        "title": "Create .prism format compiler",
        "description": "Build pattern format compiler in Rust that outputs .prism files",
        "details": "Implement .prism v1 format: 32-byte header with magic 'PRISM\\x00\\x00\\x00', version, duration, CRC32. TLV body with timeline and metadata sections. Focus on structural efficiency first (shared palettes, delta encoding). Start uncompressed, structural optimizations reduce size naturally. This is the device runtime format, replacing legacy .k1p.",
        "testStrategy": "Compile test pattern to .prism, verify header structure, CRC32 validates on device, confirm structural optimizations reduce file size",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "41",
        "title": "Implement timeline editor UI (primary creation mode)",
        "description": "Create timeline interface with drag/drop clips - available but not forced on users initially",
        "details": "Single track timeline, add/move/delete clips, snap to grid, basic undo/redo. Use React with canvas or existing timeline library. Timeline editor is the PRIMARY creation mode, but users can also browse and use templates without opening the editor. Focus on minimum viable editor that works alongside template library. Compile output to .prism format.",
        "testStrategy": "Create 3-clip timeline, compile to .prism, play on device; verify users can use app without opening timeline editor",
        "priority": "high",
        "dependencies": [
          "39",
          "40"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "42",
        "title": "Add device discovery UI",
        "description": "Create device picker with mDNS discovery and manual IP fallback",
        "details": "List discovered devices from mDNS _k1prism._tcp, show connection status, allow manual IP entry, persist last connected device. Handle connection failures gracefully.",
        "testStrategy": "Discover device on network, connect, disconnect, reconnect successfully",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "43",
        "title": "Create monorepo structure",
        "description": "Organize code into monorepo with clear separation",
        "details": "Structure: apps/studio/ (Tauri), firmware/ (ESP-IDF), libs/pattern/ (shared Rust), specs/ (documentation). Set up workspace Cargo.toml, shared dependencies, cross-compilation scripts.",
        "testStrategy": "All components build independently, shared libs link correctly",
        "priority": "low",
        "dependencies": [
          "38"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "44",
        "title": "Implement pattern storage UI",
        "description": "Show stored patterns on device with management controls",
        "details": "List patterns with sizes, show storage usage bar, delete patterns, reorder for playlist. Use their LIST/DELETE WebSocket commands.",
        "testStrategy": "List shows all patterns, delete removes from device, storage bar accurate",
        "priority": "medium",
        "dependencies": [
          "42"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "45",
        "title": "Add real-time parameter control",
        "description": "Implement live parameter updates via WebSocket",
        "details": "Send SET_PARAM commands for brightness, speed, hue shift. Update preview and device simultaneously. Use binary frames for efficiency if needed.",
        "testStrategy": "Adjust parameter in UI, see immediate change on device and preview",
        "priority": "low",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "46",
        "title": "Design template system architecture",
        "description": "Define structure for template library system supporting 15-20 curated templates",
        "details": "Design template metadata schema (name, description, duration, category, preview thumbnail, parameters). Define storage structure: embedded in desktop app vs remote CDN. Plan template categories: Ambient, Energy, Minimal, Rhythmic, etc. Define how templates relate to timeline editor (templates can be starting points or standalone). Target: 60-second out-of-box experience with zero creation required.",
        "testStrategy": "Document template schema; validate it supports all required metadata; get user approval on categories",
        "priority": "high",
        "dependencies": [
          "40",
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "47",
        "title": "Implement template library UI",
        "description": "Create browsable template gallery with preview and one-click deployment",
        "details": "Grid/list view of templates with thumbnails, category filters, search. Preview button shows Three.js visualization. Deploy button compiles template to .prism and uploads to device. Allow marking templates as favorites. Templates should feel like Netflix/Spotify browsing experience - simple, visual, immediate.",
        "testStrategy": "Browse templates, preview 3 different templates, deploy one to device, verify it plays correctly",
        "priority": "high",
        "dependencies": [
          "46",
          "39"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "48",
        "title": "Create 5 foundational templates (Phase 1)",
        "description": "Design and implement first 5 core templates covering major visual styles",
        "details": "Create templates: (1) Ambient Pulse - slow breathing effect, (2) Energy Wave - fast rhythmic motion, (3) Minimal Fade - subtle color transitions, (4) Strobe Burst - high-energy flashing, (5) Color Cycle - smooth rainbow rotation. Each template should be 10-30 seconds, use timeline format, showcase different effect types. Include preview thumbnails and metadata.",
        "testStrategy": "Deploy each template, verify visual quality matches intent, ensure all compile to .prism correctly",
        "priority": "high",
        "dependencies": [
          "46",
          "40"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "49",
        "title": "Create 10 diverse templates (Phase 2)",
        "description": "Expand template library with 10 more diverse patterns",
        "details": "Create templates covering: rhythmic patterns (3), ambient/chill (2), high-energy (2), experimental (2), holiday/themed (1). Ensure variety in speed, color palette, complexity. Each template should demonstrate different combinations of effects, palettes, and timing. Total library now 15 templates.",
        "testStrategy": "User testing: can new user find and deploy a template they like within 60 seconds? Verify visual diversity across all 15 templates",
        "priority": "high",
        "dependencies": [
          "48",
          "47"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "50",
        "title": "Add 5 advanced templates (Phase 3)",
        "description": "Create final 5 templates showcasing advanced techniques",
        "details": "Create advanced templates: (1) Multi-layer composition, (2) Complex palette transitions, (3) Beat-reactive pattern, (4) Generative/evolving pattern, (5) Showcase/demo pattern (best of all techniques). These templates serve as inspiration for users learning timeline editor. Total library now 20 templates. Focus on 'wow factor' to demonstrate system capabilities.",
        "testStrategy": "Deploy advanced templates, verify performance on device, confirm they inspire users to explore timeline editor",
        "priority": "medium",
        "dependencies": [
          "49"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "51",
        "title": "Implement template-to-timeline conversion",
        "description": "Allow users to open templates in timeline editor for customization",
        "details": "Add 'Edit Template' button that loads template into timeline editor. User can modify clips, timing, palettes, then save as custom pattern. This bridges gap between templates (easy) and timeline editor (powerful). Preserve template metadata when loading. Consider 'Save as Template' to let users share creations.",
        "testStrategy": "Open template in editor, modify it, save as custom pattern, deploy to device, verify changes applied",
        "priority": "medium",
        "dependencies": [
          "47",
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "52",
        "title": "Add template update mechanism",
        "description": "Enable updating template library without app recompilation",
        "details": "Implement remote template manifest (JSON) that desktop app fetches on launch. Templates can be updated/added via CDN without app updates. Include version checking, local caching, and fallback to embedded templates if offline. Consider update notifications when new templates available.",
        "testStrategy": "Update remote manifest, restart app, verify new templates appear; test offline mode falls back to embedded templates",
        "priority": "low",
        "dependencies": [
          "47",
          "50"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "53",
        "title": "Add node editor as experimental feature",
        "description": "Implement node-based composition editor as advanced/experimental mode",
        "details": "Node editor is FUTURE/EXPERIMENTAL feature, not part of primary workflow. Implement basic node graph UI for advanced users: effect nodes, palette nodes, parameter nodes, composition nodes. Should feel like Blender/TouchDesigner for LED patterns. Hide behind 'Advanced Mode' toggle or separate tab. Not required for 1.0 release - timeline editor is primary creation mode.",
        "testStrategy": "Create simple 2-node graph, compile to .prism, verify output matches timeline-created pattern",
        "priority": "low",
        "dependencies": [
          "41",
          "50"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-15T01:55:17.455Z",
      "taskCount": 53,
      "completedCount": 2,
      "tags": [
        "master"
      ]
    }
  }
}