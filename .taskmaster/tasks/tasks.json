{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Establish component scaffolding and runtime orchestration",
        "description": "Create ESP-IDF component structure for network, storage, playback, and templates, then wire them into the main firmware entry point with task scheduling and error propagation.",
        "details": "Implementation:\n- Create `firmware/components/{network,storage,playback,templates}` with `CMakeLists.txt`, public headers (e.g., `network_manager.h`, `pattern_storage.h`), and stub source files exposing `*_init()` and FreeRTOS task entry points.\n- Update `firmware/CMakeLists.txt` `EXTRA_COMPONENT_DIRS` to include the new components and ensure include paths export shared headers (`components/include`).\n- Extend `firmware/main/main.c` to include the new headers, call `network_init()`, `storage_init()`, `playback_init()`, `templates_init()` after `system_init()`, and create FreeRTOS tasks using the defined stack sizes and priorities.\n- Add centralized failure handling so any init error routes through `error_handler` once implemented.\nPseudo-code:\n```\nvoid app_main(void) {\n    print_system_info();\n    ESP_ERROR_CHECK(system_init());\n    ESP_ERROR_CHECK(network_init());\n    ESP_ERROR_CHECK(storage_init());\n    ESP_ERROR_CHECK(playback_init());\n    ESP_ERROR_CHECK(templates_init());\n    xTaskCreate(network_task, \"network\", STACK_NETWORK, NULL, PRIORITY_NETWORK, NULL);\n    ...\n}\n```",
        "testStrategy": "Run `idf.py build` to verify new components integrate; add Unity smoke tests that call each `*_init()` stub; flash to hardware and confirm boot log shows all init stages without watchdog resets.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold ESP-IDF component directories",
            "description": "Create initial network, storage, playback, and templates components with headers and stub sources.",
            "dependencies": [],
            "details": "Under `firmware/components`, add folders for network, storage, playback, and templates, each with `CMakeLists.txt`, a public header exposing `*_init()` and FreeRTOS task prototypes, and stub `.c` files returning `ESP_OK`.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Wire new components into build system",
            "description": "Register the new components with the firmware build configuration and shared include paths.",
            "dependencies": [
              1
            ],
            "details": "Update `firmware/CMakeLists.txt` to append the four component directories to `EXTRA_COMPONENT_DIRS`, ensure `components/include` is exported for shared headers, and confirm each component lists its public headers in `idf_component_register`.",
            "status": "done",
            "testStrategy": "Run `idf.py reconfigure` to ensure CMake picks up the new directories without errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Extend app_main for initialization and task orchestration",
            "description": "Modify the firmware entry point to initialize components and launch tasks with centralized error handling.",
            "dependencies": [
              1,
              2
            ],
            "details": "Include the new component headers in `firmware/main/main.c`, call each `*_init()` after `system_init()` wrapped in `ESP_ERROR_CHECK`, create FreeRTOS tasks with agreed stack sizes/priorities, and route any init failure through the shared `error_handler`.",
            "status": "done",
            "testStrategy": "Build the project and inspect the `app_main` flow in `idf.py monitor` once tasks are running to verify staged init logs.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add scaffolding smoke tests and build verification",
            "description": "Introduce basic tests and build checks covering the new component scaffolding and orchestrated startup.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create Unity smoke tests that call each `*_init()` stub to confirm linkage, add a CI or local script target running `idf.py build`, and document the expected boot log checkpoints for manual verification.",
            "status": "done",
            "testStrategy": "Execute Unity smoke tests via `idf.py test` (or equivalent) and run `idf.py build` to ensure the scaffolding integrates cleanly.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break this work into subtasks covering (1) creating ESP-IDF component skeletons for network/storage/playback/templates with headers and stubs, (2) updating build files and exports, (3) extending app_main to orchestrate init and FreeRTOS tasks with centralized error routing, and (4) adding smoke tests/build verification.",
        "updatedAt": "2025-10-15T17:23:29.510Z"
      },
      {
        "id": "2",
        "title": "Implement WiFi lifecycle, captive portal, and mDNS broadcasting",
        "description": "Develop the network manager component providing AP setup, STA onboarding, credential persistence, captive portal, and mDNS service advertisement per PRD requirements.",
        "details": "Implementation:\n- In `components/network/network_manager.c`, configure dual-mode WiFi: start AP (`PRISM-SETUP`) using `esp_netif_create_default_wifi_ap()`, host captive portal via `esp_http_server`, and transition to STA mode once credentials are submitted, storing them with NVS APIs.\n- Implement exponential backoff reconnect loop (`WIFI_RETRY_MAX`) with event handlers for `WIFI_EVENT` and `IP_EVENT` to maintain uptime.\n- Register mDNS using `mdns_init()` with host `\"prism-k1\"` and service `_prism._tcp`.\n- Expose `network_init()` to set up netifs and `network_task(void*)` to manage portal lifecycle and status broadcasts.\nPseudo-code:\n```\nesp_err_t network_init(void) {\n    wifi_init_config_t wifi_cfg = WIFI_INIT_CONFIG_DEFAULT();\n    ESP_ERROR_CHECK(esp_wifi_init(&wifi_cfg));\n    start_ap_portal();\n    register_event_handlers();\n    mdns_init();\n    return ESP_OK;\n}\n```\n- Ensure memory allocations use `prism_pool_alloc` where possible to avoid fragmentation.",
        "testStrategy": "Add Unity tests with `esp_event_loop_run()` mocked to validate backoff timing; on hardware, run captive portal flow and verify `mdns_query_ptr()` returns `prism-k1.local`; measure reconnect handling by cycling router power.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Establish WiFi dual-mode initialization",
            "description": "Set up foundational WiFi interfaces and event loop enabling AP and STA operation.",
            "dependencies": [],
            "details": "Initialize ESP netifs, configure PRISM-SETUP SSID via esp_netif_create_default_wifi_ap, call esp_wifi_init with default config, and expose network_init while using prism_pool_alloc for dynamic buffers.\n<info added on 2025-10-15T17:58:33.766Z>\nImplemented network_private.h with the WiFi lifecycle state machine scaffolding and declarations, updated components/network/CMakeLists.txt to pull in esp_http_server, mdns, core, and lwip, and added init_wifi_dual_mode() to initialize esp_netif, create the default event loop, bring up AP and STA netifs, set WiFi storage to RAM, and delegate AP startup to start_ap_mode() configured for the PRISM-SETUP open AP. Expanded network_init() to initialize NVS, call init_wifi_dual_mode(), register WIFI_EVENT/IP_EVENT handlers (logging only for now), launch the AP, and chain into start_captive_portal() and load_credentials_from_nvs() placeholders; introduced additional stubs (e.g., mDNS helpers) earmarked for subtasks 2.2–2.5 with build readiness confirmed under the ESP-IDF environment.\n</info added on 2025-10-15T17:58:33.766Z>",
            "status": "done",
            "testStrategy": "Create a Unity test harness that stubs esp_wifi_init and verifies network_init registers both AP and STA netifs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build captive portal HTTP workflow",
            "description": "Implement the captive portal server handling credential submission and AP lifecycle.",
            "dependencies": [
              1
            ],
            "details": "Spin up esp_http_server with handlers for credential form, serve minimal assets from flash, and ensure portal teardown triggers STA transition when credentials are posted.\n<info added on 2025-10-15T18:00:05.532Z>\nCaptive portal HTTP server implemented with embedded credential and success HTML forms, GET “/” serving the form, POST “/connect” parsing URL-encoded payloads via parse_form_data, persisting credentials through save_credentials_to_nvs, updating g_net_state, and signaling STA transition while a wildcard GET handler satisfies captive portal probes. start_captive_portal launches esp_http_server on port 80 with four sockets, LRU purge, and 4KB stack; stop_captive_portal performs graceful teardown. Form buffers now come from prism_pool_alloc and are released after use, HTML assets live in firmware, and 400/408/500 responses cover error paths. Success flow leaves the portal with credentials_available set for network_task to continue with Subtask 2.3.\n</info added on 2025-10-15T18:00:05.532Z>",
            "status": "done",
            "testStrategy": "Use Unity plus HTTP client mocks to submit credentials and confirm portal handlers return expected responses and cleanup callbacks run.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement credential persistence with NVS",
            "description": "Store and retrieve WiFi credentials securely using NVS once provided by the portal.",
            "dependencies": [
              2
            ],
            "details": "Leverage nvs_open and nvs_set_str to persist SSID/password, ensure prism_pool_alloc buffers are zeroed after use, and validate credentials before initiating STA connect.\n<info added on 2025-10-15T18:01:26.128Z>\nImplemented load_credentials_from_nvs() to open the prism_wifi namespace in read-only mode, check the u8 configured flag, and hydrate g_net_state SSID/password buffers (33/64 byte limits) with NULL-safe handling for open networks while setting credentials_available when successful. Added save_credentials_to_nvs() that opens prism_wifi in read-write mode, writes ssid/password keys with nvs_set_str (erasing password for open networks), updates configured=1, commits, and always closes the handle with proper error propagation. Documented the prism_wifi schema (configured u8, ssid string, password string), wired load into network_init() and save into portal_post_handler() so network_task can act on credentials_available, and emphasized NVS handle cleanup plus the recommendation to enable flash encryption to protect stored passwords.\n</info added on 2025-10-15T18:01:26.128Z>",
            "status": "done",
            "testStrategy": "Write NVS mock-based tests verifying credentials persist across network_task restarts and that invalid data paths trigger cleanup.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add reconnect backoff and event handlers",
            "description": "Maintain WiFi uptime through exponential backoff reconnect logic tied to system events.",
            "dependencies": [
              1,
              3
            ],
            "details": "Register WIFI_EVENT and IP_EVENT handlers, implement WIFI_RETRY_MAX governed exponential backoff, and ensure timers use prism_pool_alloc allocations while updating status broadcasts.\n<info added on 2025-10-15T18:02:57.812Z>\nImplemented start_sta_connection() to configure the STA with persisted credentials, enforce WPA2-PSK with optional PMF, and enter WIFI_MODE_STA_CONNECTING via esp_wifi_connect(); transition_to_sta_mode() now halts the captive portal while retaining AP fallback, resets retry counters (retry_count=0, retry_delay_ms=1000), and launches the first STA attempt; update_retry_delay() applies capped exponential backoff (1s, 2s, 4s, 8s, 16s, then 30s) with continuous retries after the fifth attempt; wifi_event_handler() covers AP join/leave along with the full STA lifecycle, triggering timed reconnects on disconnect, clearing counters on success, and updating mode state when the STA stops; ip_event_handler() starts or stops mDNS as IP leases are gained or lost and synchronizes mode state accordingly; network_task() now boots into STA when credentials exist, reacts to new portal credentials, and polls every five seconds for mode monitoring, leaving the subtask ready for 2.5 mDNS advertisement work.\n</info added on 2025-10-15T18:02:57.812Z>",
            "status": "done",
            "testStrategy": "Simulate event sequences in Unity to assert backoff timing increases exponentially and resets on successful connection.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Configure mDNS advertisement service",
            "description": "Expose device discovery via mDNS once STA connectivity is established.",
            "dependencies": [
              1,
              4
            ],
            "details": "Call mdns_init after WiFi stack ready, register host prism-k1 and _ws._tcp service with correct port, and ensure lifecycle hooks restart mDNS on reconnect events.\n<info added on 2025-10-15T18:03:59.113Z>\nImplemented start_mdns_service() to call mdns_init(), set hostname prism-k1 (prism-k1.local), assign instance name PRISM K1 LED Controller, and register _http._tcp and _prism._tcp services on port 80 with TXT records version=1.0, device=prism-k1, leds=320. Added stop_mdns_service() that guards with g_net_state.mdns_initialized, invokes mdns_free(), and clears the flag for idempotent teardown. start_mdns_service() now runs from ip_event_handler() on IP_EVENT_STA_GOT_IP, while stop_mdns_service() executes on IP_EVENT_STA_LOST_IP and during network_deinit(), ensuring the service restarts cleanly across reconnects. Error paths propagate mdns_* failures and ensure mdns_free() executes so partial registrations do not leak resources.\n</info added on 2025-10-15T18:03:59.113Z>",
            "status": "done",
            "testStrategy": "Mock mdns APIs to verify service registration parameters and confirm restart occurs after reconnect event sequence.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Define unit and integration validation coverage",
            "description": "Plan and script tests covering WiFi lifecycle, portal flow, persistence, and mDNS discovery.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Document Unity test cases, hardware-in-loop procedures for captive portal, reconnection cycling, and mdns_query_ptr discovery; integrate into CI runbook.\n<info added on 2025-10-15T18:05:58.853Z>\nCaptured comprehensive Unity suite under components/network/test with test_network_manager.c (23 cases spanning network init, NVS persistence, captive portal HTTP parsing, reconnection backoff, mDNS registration, integration flows, and memory safety) plus test/CMakeLists.txt and test/README.md documenting run steps and >80% coverage goals. Documented required mocks for esp_wifi, esp_netif, nvs, mdns, esp_http_server, and esp_event loop; outlined manual hardware checklists (6-step portal flow, 7-step reconnection timing, 5-step persistence power-cycle, mDNS discovery via avahi-browse/dns-sd) so validation can start immediately while mock implementation and hardware execution remain outstanding.\n</info added on 2025-10-15T18:05:58.853Z>",
            "status": "done",
            "testStrategy": "Consolidate test matrix ensuring continuous integration runs Unity suites and schedules periodic on-device verification.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Decompose into subtasks for WiFi dual-mode setup, captive portal HTTP server, credential persistence via NVS, reconnect/backoff logic with event handlers, mDNS advertisement, and unit/integration test coverage."
      },
      {
        "id": "3",
        "title": "Build WebSocket server with TLV-aware session management",
        "description": "Create a WebSocket handler supporting binary TLV messages, 4KB receive buffer, two concurrent clients, reconnection backoff, and error codes per ADR-002.",
        "details": "Implementation:\n- Under `components/network/websocket_handler.c`, use `httpd_ws_conn` from ESP-IDF to upgrade HTTP connections to WebSocket; allocate a fixed 4KB RX buffer per connection using memory pools.\n- Track active clients in a bounded array, rejecting additional connections with error 0x01.\n- Implement state machine (IDLE→RECEIVING→VALIDATING→STORING) with timers enforcing `WS_TIMEOUT_MS` and resume logic after errors.\n- Encode status frames (type 0x30) reporting heap and cache metrics from `prism_heap_monitor` and storage stats.\nPseudo-code:\n```\nstatic esp_err_t websocket_recv_task(void* arg) {\n    while (1) {\n        size_t len = WS_BUFFER_SIZE;\n        httpd_ws_recv_frame(client->hd, &frame, WS_TIMEOUT_MS);\n        switch (frame.type) {\n            case 0x10: handle_put_begin(frame.payload); break;\n            ...\n        }\n    }\n}\n```\n- Integrate exponential backoff reconnect attempts for clients and propagate errors via `error_handler`.",
        "testStrategy": "Create unit tests using `unity` with mocked `httpd_ws_recv_frame` to validate buffer boundaries and error code responses; run throughput benchmark using `idf.py monitor` with host script pushing 500KB/s payloads verifying sustained rate and no heap growth.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement WebSocket upgrade and session registry",
            "description": "Integrate ESP-IDF WebSocket upgrade flow and track connected sessions in the handler entry point.",
            "dependencies": [],
            "details": "Create the initial handler in components/network/websocket_handler.c that upgrades HTTP requests via httpd_ws_conn, persists client metadata, and initializes session bookkeeping structures.",
            "status": "pending",
            "testStrategy": "Add a Unity test with mocked httpd request objects verifying upgrade success and client slot initialization.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enforce two-client limit with fixed 4KB buffers",
            "description": "Allocate per-client receive buffers and reject excess connection attempts with ADR-002 error codes.",
            "dependencies": [
              1
            ],
            "details": "Attach a 4KB RX buffer from the memory pool to each active client and block additional upgrades by responding with error code 0x01 while freeing any provisional resources.",
            "status": "pending",
            "testStrategy": "Use Unity to simulate three connection attempts and assert only two succeed while the third receives the expected error response.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build TLV-driven session state machine",
            "description": "Implement IDLE→RECEIVING→VALIDATING→STORING states handling TLV frames and timeout enforcement.",
            "dependencies": [
              1,
              2
            ],
            "details": "Design a state machine that reads binary frames, validates TLV payloads, transitions across protocol states, and resets on timeout or validation failure while preserving resume logic.",
            "status": "pending",
            "testStrategy": "Mock httpd_ws_recv_frame delivering ordered and malformed TLVs to ensure state transitions and timeout handling follow ADR-002.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate reconnect backoff and error propagation",
            "description": "Add exponential backoff retry logic per client and route failures through error_handler.",
            "dependencies": [
              3
            ],
            "details": "Implement reconnect scheduling that escalates delays on repeated failures, invokes error_handler with ADR-002 codes, and restores sessions without leaking buffers or dangling timers.",
            "status": "pending",
            "testStrategy": "Simulate repeated disconnects to confirm increasing backoff intervals and verify error_handler captures each failure path.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Execute validation and throughput testing",
            "description": "Run automated checks covering buffer bounds, state transitions, and sustained data rates.",
            "dependencies": [
              3,
              4
            ],
            "details": "Develop Unity suites for buffer overflow prevention and state coverage, then run integration throughput checks driving 500KB/s payloads via idf.py monitor to observe heap and cache stability.",
            "status": "pending",
            "testStrategy": "Leverage existing Unity harness plus manual throughput script to confirm metrics and absence of heap growth during sustained transfers.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Outline subtasks for WebSocket upgrade handling with two-client limit, fixed-buffer management, TLV state machine implementation, reconnect/error propagation, and validation/testing including throughput checks.",
        "updatedAt": "2025-10-16T08:13:17.108Z"
      },
      {
        "id": "4",
        "title": "Implement TLV protocol parser and command dispatcher",
        "description": "Develop a protocol parser that validates TLV payloads, performs CRC checks, and dispatches commands to storage and playback subsystems.",
        "details": "Implementation:\n- Add `components/network/protocol_parser.c` with `protocol_parse_frame(const ws_frame_t*, protocol_context_t*)` that decodes `[TYPE][LEN][PAYLOAD][CRC]` per PRD, using `ws_validate_*` helpers from `prism_secure`.\n- Maintain upload context for PUT_BEGIN/DATA/END with CRC32 accumulation via `esp_rom_crc32`, ensuring 256KB size cap.\n- Map CONTROL commands to playback actions (play, pause, crossfade) and STATUS queries to telemetry assembly.\n- Provide callback hooks (`protocol_handlers_t`) so storage and playback modules register their handlers during init.\nPseudo-code:\n```\nswitch (type) {\n    case MSG_PUT_BEGIN: storage_begin_upload(payload);\n    case MSG_PUT_DATA: storage_write_chunk(offset, data, len);\n    case MSG_PUT_END: storage_finalize_upload(success_flag);\n    case MSG_CONTROL: playback_apply_command(command_id, params);\n}\n```\n- Ensure invalid sequences trigger error frames with codes 0x02/0x03.",
        "testStrategy": "Add parser unit tests feeding crafted frames to verify CRC rejection and size enforcement; run integration test with `idf.py unity` ensuring uploads stream into a mocked storage backend without fragmentation.",
        "priority": "medium",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement TLV frame validation and CRC checks",
            "description": "Add TLV parsing routine that validates headers, lengths, and CRC for inbound frames.",
            "dependencies": [],
            "details": "Create protocol_parse_frame to read TYPE/LEN/PAYLOAD/CRC, use ws_validate helpers, and accumulate CRC32 with esp_rom_crc32 while enforcing payload length limits.",
            "status": "pending",
            "testStrategy": "Write unit tests feeding malformed frames to confirm length and CRC failures return expected error codes 0x02 and 0x03.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Manage upload session state with size enforcement",
            "description": "Track PUT upload lifecycle and cap aggregated payload size at 256KB.",
            "dependencies": [
              1
            ],
            "details": "Maintain protocol_context_t fields for PUT_BEGIN/DATA/END, accumulate CRC across chunks, reject out-of-order frames, and abort sessions exceeding 256KB.",
            "status": "pending",
            "testStrategy": "Simulate segmented uploads in tests to verify CRC accumulation, overflow rejection, and invalid sequencing handling.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Wire storage command dispatch handlers",
            "description": "Forward storage-related protocol messages to registered storage callbacks.",
            "dependencies": [
              2
            ],
            "details": "Implement protocol_handlers_t registration and route MSG_PUT_* cases to storage_begin_upload, storage_write_chunk, and storage_finalize_upload with success flag resolution.",
            "status": "pending",
            "testStrategy": "Mock storage handlers in unit tests to assert correct invocation sequence and error handling when callbacks report failures.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate playback control and status dispatch",
            "description": "Handle CONTROL and STATUS frames by invoking playback callbacks and assembling telemetry responses.",
            "dependencies": [
              1
            ],
            "details": "Map MSG_CONTROL frames to playback_apply_command operations, translate payload params, and compose STATUS replies using telemetry helpers exposed via protocol_handlers_t.",
            "status": "pending",
            "testStrategy": "Add tests verifying playback command decoding, telemetry assembly, and error frame emission when handlers decline commands.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build comprehensive parser test suite",
            "description": "Create unit and integration tests covering parser, storage, and playback interactions.",
            "dependencies": [
              3,
              4
            ],
            "details": "Extend Unity test harness with crafted TLV vectors, end-to-end upload simulations, and playback command scenarios to validate protocol_parser behavior across success and failure cases.",
            "status": "pending",
            "testStrategy": "Run Unity suite and integration flows ensuring PUT uploads reach mock storage, playback commands execute, and status queries return expected telemetry.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Create subtasks for frame validation/CRC logic, upload session management with size enforcement, command-to-storage mapping, playback control hookups, and comprehensive unit/integration tests.",
        "updatedAt": "2025-10-16T08:13:17.843Z"
      },
      {
        "id": "5",
        "title": "Integrate LittleFS storage and pattern persistence APIs",
        "description": "Mount the LittleFS partition, expose pattern CRUD operations, and enforce storage quotas and CRC verification per ADR-001/005.",
        "details": "Implementation:\n- In `components/storage/pattern_storage.c`, call `esp_vfs_littlefs_register` for partition `\"littlefs\"` at mount path `/littlefs`, fail fast if formatting needed.\n- Implement APIs: `storage_init()`, `pattern_storage_open`, `pattern_storage_write_chunk`, `pattern_storage_finalize` (with CRC32), `pattern_storage_list`, and quota checks to maintain 1.5MB limit minus safety margin.\n- Use shared palette files under `/littlefs/templates` and manage atomic writes via temp files and `rename`.\nPseudo-code:\n```\nesp_err_t storage_init(void) {\n    const esp_vfs_littlefs_conf_t conf = { .base_path = STORAGE_PATH, .partition_label = STORAGE_LABEL, ... };\n    ESP_ERROR_CHECK(esp_vfs_littlefs_register(&conf));\n    return storage_verify_templates();\n}\n```\n- Wire into protocol callbacks for PUT_* handling.",
        "testStrategy": "Add Unity tests using `esp_littlefs` host stub to simulate writes and CRC mismatches; run on device with power cycle to ensure remount succeeds and files persist; monitor heap via `prism_heap_monitor_dump_stats` after repeated uploads.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Mount LittleFS partition for pattern storage",
            "description": "Configure and verify the LittleFS partition mount used by pattern storage.",
            "dependencies": [],
            "details": "Define mount constants, call esp_vfs_littlefs_register for label \"littlefs\", ensure format-on-fail is disabled, and return an error if registration fails.\n<info added on 2025-10-15T18:06:58.881Z>\nPre-implementation analysis underway: inventorying all usages of the LittleFS partition offset so the shift from 0x320000 to 0x311000 per ADR-001 updates `firmware/partitions.csv`, build artifacts under `firmware/build/log/`, and any hardcoded mount descriptors without breaking alignment or overlapping OTA slots. Also auditing every reference to `PATTERN_MIN_COUNT` (currently defined in `firmware/components/core/include/prism_config.h`) to confirm dropping the baseline to 15 per ADR-006 stays compatible with quota math, CRC validations, and existing unit/integration tests before touching code.\n</info added on 2025-10-15T18:06:58.881Z>\n<info added on 2025-10-15T18:20:55.422Z>\nIntroduce a static FreeRTOS mutex to guard mount/unmount sequencing; fetch the LittleFS partition via esp_partition_find_first and validate its offset/size against ADR-001 before mounting; call esp_vfs_littlefs_register for label littlefs at /littlefs with format_if_mount_failed kept false; emit detailed ESP_LOGE entries for each failure path (partition lookup, validation, registration, directory creation) capturing esp_err_to_name codes; on success create /littlefs/templates with mkdir and treat any errno other than EEXIST as fatal; ensure every exit path releases the mutex and propagates the precise esp_err_t to callers.\n</info added on 2025-10-15T18:20:55.422Z>\n<info added on 2025-10-15T18:23:45.091Z>\nImplementation finalized: storage_init creates a static FreeRTOS mutex, validates the ADR-007 LittleFS partition (offset 0x320000, size 0x180000) via esp_partition_find_first, mounts at /littlefs with format_if_mount_failed=false, logs detailed ESP_LOGE errors for every failure path, emits partition statistics (total/used/free) each mount, triggers an 80 percent utilization warning, and ensures /littlefs/templates exists; storage_deinit now unmounts and frees resources cleanly. Updated pattern_storage.c to encapsulate this logic and CMakeLists.txt to link esp_partition and esp_littlefs. Pending action: run idf.py build in the ESP-IDF shell to verify the build.\n</info added on 2025-10-15T18:23:45.091Z>\n<info added on 2025-10-15T18:55:56.328Z>\nRecovery plan after losing uncommitted work: re-implement the LittleFS mount flow in storage_init/storage_deinit, rerun idf.py build plus mount verification, then stage and commit the restored files before touching task status; from now on never mark a subtask complete until its git commit exists.\n</info added on 2025-10-15T18:55:56.328Z>\n<info added on 2025-10-15T19:02:44.051Z>\nRecovered implementation finalized and committed in a9e860f: storage_init/storage_deinit mount littlefs at /littlefs per ADR-005, validate the ADR-007 partition offset 0x320000 with a 1.5MB span, auto-format on first boot, log filesystem metrics, and expand pattern_storage.c (122 lines) plus pattern_storage.h (71 lines) while updating idf_component.yml to joltwallet/littlefs ^1.14.8 and adjusting CMakeLists.txt dependencies. Build verification outstanding—Captain to run idf.py build in the ESP-IDF shell. Subtask ready to hand off to 5.2 for CRUD work.\n</info added on 2025-10-15T19:02:44.051Z>",
            "status": "done",
            "testStrategy": "Add a boot-time Unity test that mocks esp_vfs_littlefs_register outcomes to confirm failures propagate.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement pattern storage CRUD APIs with quotas and CRC",
            "description": "Create the core pattern storage APIs handling file lifecycle, quotas, and data integrity checks.",
            "dependencies": [
              1
            ],
            "details": "Implement storage_init, pattern_storage_open, pattern_storage_write_chunk, pattern_storage_finalize, and pattern_storage_list using LittleFS handles, enforce 1.5MB minus safety margin, and compute CRC32 before finalizing writes.\n<info added on 2025-10-15T18:34:26.575Z>\nCompleted LittleFS CRUD module in `components/storage/pattern_storage_crud.c`, providing open/write/finalize/close/read/list/delete/stat APIs with temp-file atomicity, per-write quota checks (1.5MB minus 100KB per ADR-004), hardware-accelerated CRC32 validation, and mutex-guarded operations; added helper routines for ID/path validation and directory bootstrap, plus corresponding declarations/build entries in `pattern_storage.h` and `CMakeLists.txt`, ready for build verification.\n</info added on 2025-10-15T18:34:26.575Z>\n<info added on 2025-10-15T19:05:16.566Z>\nRecovered implementation reinstates pattern_storage_crud.c with storage_pattern_create enforcing 100 KB per pattern and a 25-pattern ceiling, storage_pattern_read validating buffers, storage_pattern_delete removing orphaned files, storage_pattern_list skipping dot entries, and storage_pattern_count reporting totals; pattern_storage.h now provides documented declarations and CMakeLists.txt builds the module. Error handling returns ESP_ERR_INVALID_ARG for null inputs, ESP_ERR_INVALID_SIZE when payloads or buffers exceed limits, ESP_ERR_NO_MEM once the 25 pattern quota is exhausted, and ESP_ERR_NOT_FOUND for missing files. Patterns persist under /littlefs/patterns/ as <pattern_id>.bin with automatic directory creation and ADR-006 bounds enforced. Changes are captured in commit 8f7e2fb and require idf.py build verification before handing off to subtask 5.3.\n</info added on 2025-10-15T19:05:16.566Z>",
            "status": "done",
            "testStrategy": "Use host-based Unity tests to simulate uploads, verify quota enforcement, and exercise CRC mismatch paths.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Handle template assets and atomic write flow",
            "description": "Manage shared template files and ensure atomic persistence semantics for pattern updates.",
            "dependencies": [
              2
            ],
            "details": "Load palette and template data from /littlefs/templates, stage writes into temporary files, perform fsync, and atomically replace targets via rename while cleaning up remnants on error.\n<info added on 2025-10-15T18:38:41.115Z>\nAdd declarations for template read/write/list utilities in pattern_storage.h and implement template_storage_write, template_storage_read, and template_storage_list so palette/template assets under /littlefs/templates use the existing temp-file + fsync + rename flow, guaranteeing temporary artifacts are removed on error paths.\n</info added on 2025-10-15T18:38:41.115Z>\n<info added on 2025-10-15T19:11:38.657Z>\nImplementation underway: add template_storage_write/template_storage_read/template_storage_list declarations to pattern_storage.h and define them in pattern_storage_crud.c so /littlefs/templates assets use the <name>.tmp staging file, call fsync before rename, and unlink any temporary artifacts on failure to keep palette/template data consistent.\n</info added on 2025-10-15T19:11:38.657Z>\n<info added on 2025-10-15T19:13:44.205Z>\nImplemented template_storage_write/read/list/delete in pattern_storage_crud.c with declarations in pattern_storage.h; template_storage_write stages writes through <name>.tmp, flushes, fsyncs via fileno, and atomically renames while every failure path unlinks temps; list skips .tmp files, delete removes residual temps and targets while auto-creating /littlefs/templates; all error exits return ESP_ERR_INVALID_ARG, ESP_ERR_NO_MEM, ESP_ERR_NOT_FOUND, ESP_ERR_INVALID_SIZE, or ESP_FAIL with cleanup; work committed in 0d9998c and the API is ready for 5.4 integration once the Task 3 WebSocket dependency lands.\n</info added on 2025-10-15T19:13:44.205Z>",
            "status": "done",
            "testStrategy": "Extend unit tests to confirm template reads succeed and that interrupted writes leave no partial files.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate storage APIs with protocol callbacks",
            "description": "Wire the new storage functions into protocol upload and control handlers.",
            "dependencies": [
              2,
              3
            ],
            "details": "Update protocol PUT_* handling to call the storage APIs, maintain upload session state, surface storage errors, and ensure quota or CRC failures translate into protocol error responses.\n<info added on 2025-10-15T19:26:00.332Z>\nIntegration plan: create a storage protocol integration layer under components/storage/ with dispatch helpers; add WebSocket command handler stubs and wire storage create/read/delete calls into the protocol callbacks; implement upload session state tracking and map quota/CRC/storage failures to protocol error responses; expose a public API callable from the WebSocket layer; update network_manager.c:1238 to replace the TLV dispatcher TODO with storage_protocol_dispatch(). Starting implementation.\n</info added on 2025-10-15T19:26:00.332Z>\n<info added on 2025-10-15T19:30:25.068Z>\nImplemented storage_protocol.c integration layer with storage_protocol_dispatch handling TLV commands 0x10 PUT_BEGIN, 0x11 PUT_CHUNK, 0x12 PUT_END, 0x20 DELETE, and 0x21 LIST, including TLV frame validation, upload session tracking keyed by pattern_id, and mapping ESP_ERR_* values to protocol error codes 0x01-0x05 with STATUS 0x30 and ERROR 0x40 responses. Added storage_protocol_is_upload_active and storage_protocol_abort_upload helpers, replaced the TLV dispatcher TODO at network_manager.c:1238 with storage_protocol_dispatch, and confirmed the protocol layer is ready for WebSocket integration. Changes committed in b7e6dc8.\n</info added on 2025-10-15T19:30:25.068Z>",
            "status": "done",
            "testStrategy": "Add integration-level tests using mocked protocol frames to verify successful uploads and error propagation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Execute persistence validation and endurance tests",
            "description": "Plan and run verification covering filesystem persistence, power cycling, and memory usage.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Run Unity tests with esp_littlefs host stub, perform on-device upload cycles with power resets to confirm remount and data persistence, and capture heap metrics after repeated transfers.",
            "status": "pending",
            "testStrategy": "Document and execute the endurance runbook, capturing results and logs for regression tracking.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Split into subtasks covering LittleFS mount/config, CRUD API implementations with quotas/CRC, template file handling and atomic updates, protocol integration points, and test strategy execution.",
        "updatedAt": "2025-10-16T08:13:18.621Z"
      },
      {
        "id": "6",
        "title": "Create .prism pattern format parser and metadata validation",
        "description": "Implement parsing and validation for the 1KB header, shared palettes, and delta-encoded payloads to guarantee instant access and structural efficiency.",
        "details": "Implementation:\n- Introduce `components/storage/pattern_format.c` with `pattern_format_parse(const uint8_t* header, size_t header_len, pattern_descriptor_t* out)` enforcing limits: version 0x01, <=256KB payload, valid palette references.\n- Decode metadata fields (name, category, parameters) using `safe_memcpy` and guard lengths; implement delta decode routines that can stream into cache without extra heap allocations.\n- Provide functions to serialize metadata for STATUS responses and to validate template headers during boot.\nPseudo-code:\n```\nesp_err_t pattern_format_parse(...) {\n    if (header_len != 1024) return ESP_ERR_INVALID_SIZE;\n    parse_fixed_header();\n    parse_palette_table();\n    parse_parameter_blocks();\n}\n```\n- Document struct definitions in `pattern_format.h` for re-use by playback engine.",
        "testStrategy": "Create offline tests feeding golden `.prism` headers to verify parsing correctness; fuzz header parser via Unity with random data ensuring graceful failures; benchmark parsing time to confirm <5ms per pattern using `esp_timer_get_time`.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement 1KB header parser with strict validation",
            "description": "Create parsing logic that verifies the 1024-byte header, version tag, and payload size caps before populating pattern descriptors.",
            "dependencies": [],
            "details": "Add pattern_format_parse skeleton in components/storage/pattern_format.c that checks header_len, version byte equals 0x01, payload length <= 256KB, and records offsets for later decoding using safe_memcpy.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Decode palette table and metadata fields safely",
            "description": "Parse shared palette references and metadata strings while preventing buffer overruns and invalid indices.",
            "dependencies": [
              1
            ],
            "details": "Extend parser to walk palette table entries, confirm indices within shared palette limits, and decode name/category/parameter blocks with safe_memcpy plus length guards defined in pattern_format.h.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement streaming delta payload decoder routines",
            "description": "Build delta decoding helpers that can stream pattern payloads directly into cache without heap allocations.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create functions that process delta-encoded sections sequentially, reuse small stack buffers, validate segment boundaries, and expose streaming callbacks for the playback engine integration.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add parser regression tests and fuzz harness",
            "description": "Develop automated coverage to validate nominal parsing, edge cases, and failure behavior for malformed headers.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Set up Unity-based golden header tests, random input fuzz seeds, and timing checks ensuring parsing completes under 5ms while asserting deliberate error codes on corrupt data.",
            "status": "pending",
            "testStrategy": "Unity golden-header suite plus fuzz harness injecting random headers to confirm graceful failures and timing assertions.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Define subtasks for header parsing/validation, palette and metadata decoding with bounds checks, delta payload streaming routines, and test/fuzz coverage for parser robustness."
      },
      {
        "id": "7",
        "title": "Implement RAM hot cache with LRU eviction and preloading",
        "description": "Manage in-memory pattern cache (3-5 entries) to guarantee <100ms switching while respecting the 150KB heap budget.",
        "details": "Implementation:\n- Add `components/storage/cache_manager.c` exposing `cache_init(max_entries)`, `cache_preload(category_defaults)`, `cache_get(pattern_id)`, using memory pools for buffer allocations.\n- Track entries with LRU metadata and preload popular templates at boot; integrate with pattern storage to load headers/payloads once and share palette blocks across cached items.\n- Hook cache lookups into playback control path so template switches reference cached buffers.\nPseudo-code:\n```\ncache_entry_t* cache_get(const char* pattern_id) {\n    entry = lru_find(pattern_id);\n    if (!entry) {\n        entry = cache_load_from_storage(pattern_id);\n    }\n    return entry;\n}\n```\n- Provide metrics to WebSocket STATUS frames (cached count, misses).\n",
        "testStrategy": "Add unit tests that simulate repeated pattern requests to assert LRU eviction order; run long-duration soak test (simulate 24h pattern cycling) while monitoring heap fragmentation via `heap_caps_check_integrity_all` and ensure cache hit rate meets targets.",
        "priority": "medium",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define cache manager structures and memory pools",
            "description": "Create the cache manager module skeleton with structs for entries, memory pools, and public API in cache_manager.c/.h.",
            "dependencies": [],
            "details": "Set up cache metadata structs, memory pool initialization for 3-5 entries within 150KB, and stub the cache_init/cache_get/cache_preload functions with TODO markers.",
            "status": "pending",
            "testStrategy": "Add initial unit tests that instantiate the cache and confirm pool allocation within budget.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement preload workflow tied to pattern storage",
            "description": "Wire cache_preload to load category defaults from storage templates into shared buffers at boot.",
            "dependencies": [
              1
            ],
            "details": "Use pattern storage APIs to fetch headers/payloads, reuse palette blocks, and ensure preload respects pool limits while flagging loaded entries.",
            "status": "pending",
            "testStrategy": "Write unit tests mocking storage calls to ensure preload populates expected entries and handles storage failures.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Finalize LRU eviction and playback integration",
            "description": "Complete cache_get logic with LRU tracking and connect playback control path to cached buffers.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement LRU queue updates, eviction when pools are full, and hook playback code paths to request entries via cache_get and handle cache misses.",
            "status": "pending",
            "testStrategy": "Create simulated playback sequence tests verifying eviction order, miss handling, and <100ms access via timing mocks.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Expose cache metrics to WebSocket status frames",
            "description": "Add instrumentation reporting cache counts, hits, and misses through existing telemetry channels.",
            "dependencies": [
              3
            ],
            "details": "Track counters inside cache manager, extend status frame assembly to include cache metrics, and ensure thread-safe reads.",
            "status": "pending",
            "testStrategy": "Extend telemetry unit tests to validate metrics payload fields and values after cache operations.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Execute stress and soak testing scenarios",
            "description": "Design and run stress scenarios that validate cache stability, memory integrity, and performance targets.",
            "dependencies": [
              3,
              4
            ],
            "details": "Script 24-hour pattern cycling with varied patterns, check heap integrity via heap_caps_check_integrity_all, and log cache hit/miss ratios.",
            "status": "pending",
            "testStrategy": "Automate soak test harness that verifies integrity checks pass and hit rate maintains required threshold.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Plan subtasks for cache data structures and memory pool wiring, preload routines tied to storage/templates, LRU eviction/path integration with playback, metrics instrumentation, and stress testing."
      },
      {
        "id": "8",
        "title": "Develop RMT-based LED driver with double buffering",
        "description": "Implement a playback driver that streams frames to 320 WS2812B LEDs at 60 FPS using double-buffered DMA-friendly memory.",
        "details": "Implementation:\n- In `components/playback/led_driver.c`, configure RMT TX channel (`rmt_new_tx_channel`) with 3.2MHz clock and install WS2812 encoder (ESP-IDF LED strip driver) or custom translator to meet timing.\n- Allocate two frame buffers via `heap_caps_malloc(MALLOC_CAP_DMA)` and expose APIs `led_driver_submit_frame(const uint8_t* frame)` and `led_driver_swap_buffers()`.\n- Use hardware timer or animation scheduler to trigger frame swaps while ensuring ISR-safe operations.\nPseudo-code:\n```\nstatic void led_refresh_task(void* arg) {\n    while (1) {\n        rmt_transmit(channel, encoder, front_buffer, frame_len, &tx_config);\n        xSemaphoreTake(frame_ready_sem, pdMS_TO_TICKS(frame_period));\n        swap_buffers();\n    }\n}\n```\n- Implement diagnostics for underruns and log if frame time exceeds 16.6ms.",
        "testStrategy": "Create hardware-in-the-loop test sending gradient frames and verifying with logic analyzer that timing meets WS2812 spec; add simulated unit tests using IDF RMT mock to ensure buffer swaps occur within deadline; monitor CPU utilization via `esp_pm_lock_type` metrics.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure RMT channel and WS2812 encoder",
            "description": "Set up the RMT TX peripheral to meet WS2812 timing requirements.",
            "dependencies": [],
            "details": "Configure `rmt_new_tx_channel` at 3.2MHz, install WS2812 encoder or custom translator, and tune timing constants for 320 LEDs.",
            "status": "done",
            "testStrategy": "Unit-test encoder configuration with IDF RMT mock to verify timing parameters.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement DMA-capable double-frame buffers",
            "description": "Create double-buffered LED frame storage using DMA-capable memory.",
            "dependencies": [
              1
            ],
            "details": "Allocate two frame buffers with `heap_caps_malloc(MALLOC_CAP_DMA)`, manage ownership, and ensure alignment for RMT transfers.",
            "status": "done",
            "testStrategy": "Add allocation tests ensuring buffers meet DMA capabilities and verify swap readiness logic in isolation.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Design frame submission and swap APIs",
            "description": "Expose APIs for frame submission and buffer swapping.",
            "dependencies": [
              2
            ],
            "details": "Implement `led_driver_submit_frame` to copy new frames into the back buffer and `led_driver_swap_buffers` to rotate buffers safely.",
            "status": "done",
            "testStrategy": "Mock submit/swap calls to confirm data integrity and buffer state transitions without RMT involvement.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate timing control and ISR-safe workflow",
            "description": "Coordinate frame transmission timing and ISR-safe synchronization.",
            "dependencies": [
              3
            ],
            "details": "Use hardware timer or scheduler to trigger `rmt_transmit`, manage semaphores for frame readiness, and ensure swaps occur within ISR constraints.",
            "status": "done",
            "testStrategy": "Create FreeRTOS timer tests simulating 60 FPS cadence to verify semaphore timing and ISR-safe operations.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add underrun diagnostics and validation tests",
            "description": "Implement runtime diagnostics and verification for frame timing.",
            "dependencies": [
              4
            ],
            "details": "Log underruns when frame time exceeds 16.6ms, expose metrics, and validate behavior via hardware-in-the-loop and simulated tests.",
            "status": "done",
            "testStrategy": "Run HIL gradient playback with logic analyzer plus simulated tests checking logged diagnostics and timing thresholds.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into subtasks for RMT channel/config setup, DMA-capable double-buffer management, frame submission/swap API design, timing/ISR coordination, and validation via hardware and simulated tests."
      },
      {
        "id": "9",
        "title": "Build effect engine with parameter interpolation and crossfade scheduler",
        "description": "Translate parsed pattern instructions into frame buffers with smooth parameter transitions and <100ms switch latency.",
        "details": "Implementation:\n- Implement `components/playback/effect_engine.c` to interpret pattern descriptors, generate frame deltas, and manage crossfades between patterns using eased interpolation (e.g., cubic). Maintain per-pattern state machines.\n- Add `animation_timer.c` to configure a 60 FPS hardware timer (`esp_timer_create_periodic`) that triggers rendering pipelines and interacts with the LED driver.\n- Provide APIs `effect_engine_play(pattern_descriptor_t*, playback_params_t*)`, `effect_engine_set_parameters(...)`, `effect_engine_update()` invoked by the timer callback.\nPseudo-code:\n```\nstatic void animation_tick(void* arg) {\n    blend_progress = compute_easing(step++);\n    generate_frame(active_pattern, blend_progress, scratch_buffer);\n    led_driver_submit_frame(scratch_buffer);\n}\n```\n- Ensure CPU usage stays <50% by profiling loops and using fixed-point math where feasible.",
        "testStrategy": "Create bench tests that render synthetic patterns and measure frame time with `esp_timer_get_time`; validate crossfades by sampling LED buffer outputs; run integration test by issuing CONTROL messages triggering parameter ramps and confirming transitions remain smooth.",
        "priority": "medium",
        "dependencies": [
          "6",
          "7",
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define effect engine architecture and state flow",
            "description": "Design the effect engine module structure, state machines, and data contracts for pattern playback.",
            "dependencies": [],
            "details": "Outline structs for pattern descriptors, per-pattern state, and frame buffers; document state transitions and public API contracts matching playback requirements.",
            "status": "pending",
            "testStrategy": "Review design doc with team and validate state diagrams against PRD scenarios",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement pattern interpretation and crossfade core",
            "description": "Code the effect engine logic to interpret descriptors, run state machines, and compute eased crossfades.",
            "dependencies": [
              1
            ],
            "details": "Implement frame delta generation, easing curve calculation, and state transitions in `components/playback/effect_engine.c`, ensuring parameter interpolation hooks are present.",
            "status": "pending",
            "testStrategy": "Add unit tests for easing curves and state transitions using synthetic descriptors",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build 60 FPS animation timer and update loop",
            "description": "Create the animation timer module to drive effect updates and call the engine each frame.",
            "dependencies": [
              1,
              2
            ],
            "details": "Develop `animation_timer.c` using `esp_timer_create_periodic` at 60 FPS, wiring callbacks to `effect_engine_update()` and handling timer lifecycle APIs.",
            "status": "pending",
            "testStrategy": "Write timer mock tests verifying 60 FPS cadence and correct invocation of engine hooks",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate LED driver and cache handoff",
            "description": "Connect the effect engine output with LED driver submission and RAM cache fetch paths.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement buffer handoff to `led_driver_submit_frame`, ensure cache lookups provide pattern data, and manage scratch buffer reuse with minimal allocations.",
            "status": "pending",
            "testStrategy": "Create integration test stubs that simulate cache hits/misses and assert driver submissions receive expected buffers",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimize and profile effect engine performance",
            "description": "Profile the engine loop and apply optimizations to meet CPU budget and latency constraints.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Instrument timing with `esp_timer_get_time`, convert hot paths to fixed-point math, and verify CPU usage remains under 50 percent with representative patterns.",
            "status": "pending",
            "testStrategy": "Add profiling harness measuring frame computation time and CPU load under mixed pattern workloads",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Develop bench and integration testing suite",
            "description": "Assemble bench tests and end-to-end integration validations for the effect engine.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Implement synthetic pattern benches, parameter ramp tests, and crossfade validation scripts ensuring smooth transitions and <100ms switch latency.",
            "status": "pending",
            "testStrategy": "Run automated bench tests plus hardware-in-loop scenarios sampling LED outputs and verifying timing metrics",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Segment into subtasks for pattern interpretation pipeline, crossfade/interpolation algorithms, render scheduling via timers, integration with LED driver/cache, performance profiling, and bench/integration testing."
      },
      {
        "id": "10",
        "title": "Deliver template system with 15 categorized patterns and deployment flow",
        "description": "Ship built-in templates (Ambient, Energy, Special), preload them on first boot, and expose metadata for one-click deployment via WebSocket.",
        "details": "Implementation:\n- Populate `components/templates/template_patterns.c` with 15 template descriptors referencing shared palette data and precomputed parameter curves; ensure total storage fits 1.5MB partition.\n- Implement `template_loader.c` to copy templates into LittleFS on first boot (if absent), register metadata (name, preview hash, category) with cache manager, and provide APIs `templates_init()`, `templates_list(category)`, `templates_deploy(id)`.\n- Integrate with protocol dispatcher so CONTROL commands trigger deployments and with cache to guarantee templates are cached at boot.\nPseudo-code:\n```\nesp_err_t templates_init(void) {\n    for each template_def in builtin_templates {\n        if (!storage_exists(template_def.id)) {\n            storage_write_template(template_def);\n        }\n        cache_preload(template_def.id);\n    }\n    return ESP_OK;\n}\n```\n- Update STATUS payloads to include template metadata snapshots for clients.",
        "testStrategy": "Add unit tests verifying template install idempotency and category counts (5 each); flash firmware and confirm first boot copies occur within 60s; use WebSocket CONTROL `deploy` to measure <2s deployment and <100ms playback switch via logs.",
        "priority": "medium",
        "dependencies": [
          "5",
          "6",
          "7",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define built-in template descriptors",
            "description": "Create the 15 categorized template descriptors with shared palette and curve references in template_patterns.c.",
            "dependencies": [],
            "details": "Author Ambient, Energy, and Special template structs referencing shared palette data and precomputed parameter curves while verifying the combined binary payload fits within the 1.5MB partition budget.",
            "status": "pending",
            "testStrategy": "Add static asserts or unit tests verifying descriptor counts per category and aggregate storage footprint under 1.5MB.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement first-boot template provisioning",
            "description": "Build template_loader.c routines to seed LittleFS with built-in templates when missing.",
            "dependencies": [
              1
            ],
            "details": "Write logic to detect absent templates on initial boot, copy compiled descriptors into LittleFS, and ensure idempotent storage writes using existing pattern storage APIs for reliability.",
            "status": "pending",
            "testStrategy": "Create integration-style tests stubbing LittleFS to confirm first boot populates files once and subsequent boots skip rewrites.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Register template metadata and cache preload",
            "description": "Integrate metadata cataloging and cache warming after templates are provisioned.",
            "dependencies": [
              2
            ],
            "details": "Expose templates_init/list/deploy APIs that register name, preview hash, and category with the cache manager and trigger cache_preload calls for all templates during initialization.",
            "status": "pending",
            "testStrategy": "Extend unit tests to assert metadata registry contents and that cache_preload executes for every template id after initialization.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Wire deployment flow through protocol dispatcher",
            "description": "Connect CONTROL/WebSocket commands to template deployment routines and update STATUS payloads.",
            "dependencies": [
              3
            ],
            "details": "Update protocol dispatcher handlers to call templates_deploy on CONTROL commands, stream deployment notifications over WebSocket, and embed template metadata snapshots in STATUS payloads for client discovery.",
            "status": "pending",
            "testStrategy": "Use protocol dispatcher tests that simulate CONTROL deploy commands and verify WebSocket/status messages reflect the selected template id and metadata.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Validate storage size and deployment performance",
            "description": "Measure template storage usage and runtime deployment behavior against targets.",
            "dependencies": [
              4
            ],
            "details": "Instrument measurements ensuring total template data stays under 1.5MB, first-boot provisioning completes within 60 seconds, and WebSocket deployments achieve <2s launch with <100ms playback switch via logs.",
            "status": "pending",
            "testStrategy": "Run on-device tests capturing provisioning timestamps and deployment latency while asserting log-derived metrics meet storage and performance thresholds.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Create subtasks for authoring template data structures, first-boot install and storage sync, cache preload and metadata registration, protocol/WebSocket deployments, and verification of size/performance targets."
      },
      {
        "id": "11",
        "title": "Create Motion & Sync Enumerations and Temporal Interfaces",
        "description": "Establish the core enums, data structures, and public APIs for motion and sync modes required by the temporal sequencing system.",
        "details": "Files: firmware/components/playback/include/prism_motion.h.\nSteps:\n1. Define `typedef enum` values for `motion_direction_t` {LEFT, RIGHT, CENTER, EDGE, STATIC} and `sync_mode_t` {SYNC, OFFSET, PROGRESSIVE, WAVE, CUSTOM} per ADR-010.\n2. Introduce structs:\n   - `sync_params_t { uint16_t delay_ms; uint16_t progressive_start_ms; uint16_t progressive_end_ms; uint16_t wave_amplitude_ms; uint16_t wave_frequency_hz; uint16_t wave_phase_deg; }`.\n   - `prism_temporal_ctx_t { uint16_t frame_index; const prism_pattern_t *pattern; const sync_params_t *params; }`.\n3. Declare `void prism_motion_init(prism_temporal_ctx_t *ctx);` and `void calculate_ch2_frame(prism_temporal_ctx_t *ctx, uint16_t *ch1_frame, uint16_t *ch2_frame, size_t led_count, TickType_t tick_now);`.\nPseudo-code:\n```\ntypedef struct {\n    motion_direction_t motion;\n    sync_mode_t sync_mode;\n    sync_params_t sync_params;\n} prism_temporal_header_t;\n```\n4. Document API expectations (static allocations, 160 LEDs, 320-byte buffers).\n5. Export constants for timing budgets (e.g., `#define PRISM_LGP_LED_COUNT 160`).",
        "testStrategy": "Author unit test skeleton in test_prism_temporal.c verifying enums map to expected integer values and header structs align with protocol requirements via `sizeof` static assertions.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add prism_motion_t enum and validation macro",
            "description": "Define the motion direction enum alongside its validation helper in the shared playback header.",
            "dependencies": [],
            "details": "Update firmware/components/playback/include/led_playback.h to declare typedef enum prism_motion_t with STATIC=0, LEFT, RIGHT, CENTER, EDGE and add IS_VALID_MOTION macro consistent with ADR-010 direction table.",
            "status": "pending",
            "testStrategy": "Confirm firmware headers compile cleanly by running the existing playback target build or lint step.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create prism_sync_mode_t enum with validation macro",
            "description": "Introduce sync mode enumeration definitions and validation macro in the playback include file.",
            "dependencies": [
              1
            ],
            "details": "Extend firmware/components/playback/include/led_playback.h with typedef enum prism_sync_mode_t starting at SYNC=0 followed by OFFSET, PROGRESSIVE, WAVE, CUSTOM and implement IS_VALID_SYNC macro mirroring ADR-010 sync specifications.",
            "status": "pending",
            "testStrategy": "Rebuild the playback component to ensure new enum and macro integrate without compiler diagnostics.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add temporal enum validation unit tests",
            "description": "Author unit tests covering enum ordinal values and macro validation behavior.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create firmware/components/tests/test_temporal_enums.c Unity cases asserting motion/sync enum integer values, static_assert bounds, and that IS_VALID_MOTION/IS_VALID_SYNC accept valid constants while rejecting out-of-range inputs.",
            "status": "pending",
            "testStrategy": "Run the Unity test target (e.g., idf.py test playback) to verify the new temporal enum tests execute and pass.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Define motion and sync enums with validation",
            "description": "Create the new prism_motion.h header declaring motion and sync enumerations required per ADR-010.",
            "dependencies": [],
            "details": "Author typedef enums for motion_direction_t and sync_mode_t with five modes plus *_COUNT sentinels, add PRISM_MOTION_IS_VALID-style validation macros, and include static_assert checks for enum widths.",
            "status": "pending",
            "testStrategy": "Add compile-time static_assert checks and a Unity enum-value test skeleton in test_prism_temporal.c verifying ordinal mapping.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add temporal context structs and ownership docs",
            "description": "Implement the shared temporal context and sync parameter structs that consume the new enums.",
            "dependencies": [
              4
            ],
            "details": "Define sync_params_t and prism_temporal_ctx_t with uint16_t fields, include delay_table pointer wiring, and document ownership/lifetime expectations for pattern and params references in the public header.",
            "status": "pending",
            "testStrategy": "Extend test_prism_temporal.c to assert sizeof/layout expectations and validate null/const assumptions in doc comments.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Introduce pattern metadata header aligned with new enums",
            "description": "Create auxiliary pattern_metadata.h to hold packed metadata that leverages the motion/sync enums and parameters.",
            "dependencies": [
              4,
              5
            ],
            "details": "Define prism_pattern_meta_v11_t as a packed struct containing version, motion_direction_t, sync_mode_t, sync_params_t, and CRC fields, integrating with pattern_storage.h contract and documenting serialization expectations.",
            "status": "pending",
            "testStrategy": "Plan alignment and CRC integration checks via sizeof/static_assert coverage and future pattern_storage parsing tests.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the work into defining enums, declaring shared structs/context headers, and documenting/testing the new public API expectations for motion and sync interfaces.",
        "updatedAt": "2025-10-16T08:45:10.524Z"
      },
      {
        "id": "12",
        "title": "Implement SYNC and OFFSET Temporal Sequencing",
        "description": "Develop the initial calculate_ch2_frame() logic supporting SYNC and OFFSET modes with timing guarantees.",
        "details": "Files: firmware/components/playback/prism_temporal.c.\nSteps:\n1. Implement `prism_motion_init` to zero context and validate pointers.\n2. Implement `calculate_ch2_frame` with early exit for SYNC copying `memcpy(ch2_frame, ch1_frame, led_count * sizeof(*ch1_frame));`.\n3. For OFFSET mode, compute delay buckets:\n```\nstatic inline uint16_t apply_offset(uint16_t base_value, uint16_t delay_ms, uint32_t frame_time_ms){\n    if(frame_time_ms < delay_ms) return 0;\n    return base_value; // simple first-pass all-or-nothing\n}\n```\n4. Use FreeRTOS `xTaskGetTickCount()` passed in to maintain 120 FPS budget; convert delays using `esp_timer_get_time()` if tick resolution insufficient.\n5. Cache previous frame timestamp in static context to maintain 3.38 ms CPU budget (avoid expensive math).\n6. Instrument microsecond timings with `esp_timer_get_time()` under `CONFIG_PRISM_PROFILE_TEMPORAL`.\n7. Guard all operations with static allocations and no heap usage.",
        "testStrategy": "Add unit tests mocking frames: verify SYNC outputs identical arrays; OFFSET with 150ms shift results in expected zero-filled leading frames; confirm processing time <3.38ms via `unity` performance assertions.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement prism_motion_init context validation",
            "description": "Create the motion initialization routine that validates input pointers and zeros the temporal context structure.",
            "dependencies": [],
            "details": "Use PRISM_CHECK_ARG macros to guard null pointers, memset the provided context to zero, initialize cached timestamps, and return esp_err_t codes across firmware/components/playback/prism_temporal.c.",
            "status": "pending",
            "testStrategy": "Add Unity tests that pass null pointers and valid inputs to confirm ESP_ERR_INVALID_ARG handling and full context reset.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add prism_frame_time_ms and apply_offset helpers",
            "description": "Introduce shared inline helpers that compute frame durations and gate delayed output values for temporal sequencing.",
            "dependencies": [
              1
            ],
            "details": "Create static inline functions in prism_temporal.c that convert FreeRTOS tick counts to milliseconds, fall back to esp_timer_get_time when finer resolution is required, and implement apply_offset returning zero until delay_ms elapses.",
            "status": "pending",
            "testStrategy": "Unit-test helper behavior with mocked tick counts and microsecond timers to confirm correct millisecond calculation and delay gating.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement calculate_ch2_frame SYNC branch",
            "description": "Wire up the SYNC path in calculate_ch2_frame to perform an optimized copy from channel 1 to channel 2.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add early exit for SYNC mode using memcpy on restrict-qualified buffers, respect 4-byte alignment optimizations, and integrate optional profiling guards controlled by CONFIG_PRISM_PROFILE_TEMPORAL.",
            "status": "pending",
            "testStrategy": "Create unit coverage ensuring SYNC mode copies all LED values correctly and triggers profiling hooks when enabled.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement calculate_ch2_frame OFFSET branch",
            "description": "Complete the OFFSET mode logic that applies per-LED delay buckets and handles zero-filling before activation.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Iterate LEDs, compute frame_time_ms via helpers, apply delay table values, zero-fill elements when frame_time is below delay, and cache previous frame timestamps in static context to stay within the 3.38 ms budget.",
            "status": "pending",
            "testStrategy": "Verify OFFSET mode with mocked delay tables yields expected zero-fill windows and updates cached timing without exceeding processing budget in unit tests.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Unity tests for SYNC and OFFSET modes",
            "description": "Author test_prism_temporal.c to validate SYNC copying, OFFSET delay handling, and performance instrumentation requirements.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add Unity cases that mock esp_timer_get_time, assert channel equality for SYNC, confirm OFFSET zero windows at configured delays, and use timing hooks to enforce the <3.38 ms processing target.",
            "status": "pending",
            "testStrategy": "Run new Unity suite focused on prism_temporal.c verifying both functional outputs and instrumentation-driven performance guards.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Separate tasks for context init, SYNC fast path, OFFSET delay handling, performance/timing safeguards, and unit/integration test coverage for both modes.",
        "updatedAt": "2025-10-16T08:45:11.282Z"
      },
      {
        "id": "13",
        "title": "Extend .prism v1.1 Header and Parser",
        "description": "Update storage and protocol parsing to support new motion and sync metadata in .prism v1.1 files.",
        "details": "Files: pattern_storage.h, protocol_parser.c, firmware/components/playback/prism_temporal.c (for struct integration).\nSteps:\n1. Update `prism_header_t` adding fields: `motion_direction_t motion; sync_mode_t sync_mode; sync_params_t sync_params;` ensuring total header size 70 bytes.\n2. Adjust CRC32 computation to include new fields and maintain backward compatibility by zero-filling when absent.\n3. Update `protocol_parser.c` TLV handling to accept `PRISM_VERSION_1_1`, parse motion/sync TLVs, validate range (motion enum bounds, sync modes known, delay <=500ms).\n4. Support fallback for v1.0 patterns by defaulting to `motion=STATIC`, `sync_mode=SYNC`, zeroed params.\n5. Expose helper `bool prism_pattern_is_legacy(const prism_header_t *header);` for migration tooling.\nPseudo-code snippet:\n```\nif (version == 0x0101) {\n    header->motion = read_u8();\n    header->sync_mode = read_u8();\n    header->sync_params.delay_ms = read_u16();\n    // ...\n} else {\n    header->motion = MOTION_STATIC;\n    header->sync_mode = SYNC_MODE_SYNC;\n}\n```\n6. Regenerate binary layout docs in ADR-009 appendix to note offsets.",
        "testStrategy": "Create parser unit tests using golden binaries for v1.0 and v1.1 ensuring CRC acceptance, correct field population, and rejection for out-of-range enums.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend prism_header_t for v1.1 motion and sync metadata",
            "description": "Modify the prism_header_t definition so the v1.1 binary header expands to 70 bytes and accommodates motion and sync metadata.",
            "dependencies": [],
            "details": "Insert motion_direction_t, sync_mode_t, and sync_params_t fields at byte offsets 56-63, apply packed alignment pragmas or attributes, and add static_assert checks to guarantee sizeof(prism_header_t)==70.",
            "status": "pending",
            "testStrategy": "Compile-time sizeof assertions and a layout inspection unit test that serializes the header and verifies offsets.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Introduce motion and sync TLVs in protocol_parser.c",
            "description": "Update the TLV parser to recognize the new motion and sync TLVs and populate the extended header fields when version >= 0x0101.",
            "dependencies": [
              1
            ],
            "details": "Define PRISM_TLV_MOTION=0x20 and PRISM_TLV_SYNC=0x21, enforce expected payload lengths, gate parsing to PRISM_VERSION_1_1+, and reject values outside enum bounds or >500 ms delay.",
            "status": "pending",
            "testStrategy": "Parser unit tests feeding crafted TLVs to confirm acceptance of valid frames and rejection of malformed or out-of-range inputs.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement v1.0 fallback and zero-fill compatibility path",
            "description": "Ensure legacy patterns without motion or sync TLVs default to safe values and zeroed fields while staying CRC-compatible.",
            "dependencies": [
              1,
              2
            ],
            "details": "Detect headers/version <0x0101, set motion=MOTION_STATIC, sync_mode=SYNC_MODE_SYNC, zero sync_params, and guarantee padding bytes are cleared before CRC operations or serialization.",
            "status": "pending",
            "testStrategy": "Regression tests loading v1.0 headers to verify default population and that emitted headers remain byte-identical to legacy expectations.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Extend CRC32 computation for new header fields",
            "description": "Adjust CRC accumulation logic so the new motion and sync bytes factor into the checksum without breaking older assets.",
            "dependencies": [
              1,
              3
            ],
            "details": "Update CRC32 routines to include bytes 56-69 for v1.1 headers, zero-initialize missing fields for legacy payloads prior to hashing, and validate endianness when reading multi-byte sync parameters.",
            "status": "pending",
            "testStrategy": "CRC unit tests comparing computed checksums against golden values for both 64-byte v1.0 and 70-byte v1.1 headers, plus tampered-field detection cases.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add regression tests and ADR-009 documentation updates",
            "description": "Create comprehensive tests and documentation artifacts covering the expanded header layout and parser behavior.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Author unit tests using golden binaries for both header versions, cover corrupted CRC and enum range rejections, and regenerate ADR-009 appendix diagrams with updated byte offsets.",
            "status": "pending",
            "testStrategy": "Golden-binary based tests in the playback suite and documentation checks ensuring ADR-009 reflects the new 70-byte layout and TLV handling.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Create subtasks for struct size updates, CRC/backward-compat adjustments, TLV parsing with validation, legacy defaults, and regression tests plus documentation updates.",
        "updatedAt": "2025-10-16T08:42:20.971Z"
      },
      {
        "id": "14",
        "title": "Integrate Temporal Calculation with Playback Task",
        "description": "Wire the new calculation logic into led_playback.c and generate baseline sample patterns.",
        "details": "Files: firmware/components/playback/led_playback.c, firmware/components/playback/prism_temporal.c, pattern files in assets/.\nSteps:\n1. Update `playback_task()` to construct `prism_temporal_ctx_t` from loaded pattern header and call `calculate_ch2_frame()` each frame.\n2. Ensure double-buffer safety: `uint16_t ch2_frame[PRISM_LGP_LED_COUNT]` allocated static per task.\n3. Add switch over motion enum to handle direction-specific indexing (LEFT/RIGHT etc.) for future modes (stub now but return input unchanged).\n4. Create 3 demo patterns (.prism) for SYNC, OFFSET rising (delay 0→150ms), OFFSET falling (150→0ms) stored under `.taskmaster/docs/patterns/phase1/`.\n5. Include event logging `ESP_LOGD(TAG, \"temporal mode=%d motion=%d frame=%u\", ...)` guarded by debug flag.",
        "testStrategy": "Run integration unit test with simulated playback loop verifying ch2 buffer updates and that log instrumentation toggles with config flag; confirm patterns load successfully via existing playback regression test harness.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add static ch2 buffer lifecycle hooks",
            "description": "Introduce a persistent channel 2 frame buffer in led_playback.c and manage its initialization.",
            "dependencies": [],
            "details": "Declare static uint16_t ch2_frame[PRISM_LGP_LED_COUNT] within led_playback.c, ensure it zeroes when playback_task swaps patterns, and only write to it inside frame calculation routines to maintain double-buffer safety.",
            "status": "pending",
            "testStrategy": "Add unit coverage ensuring buffer zeros on pattern changes and is untouched by unrelated code paths.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build prism_temporal context from pattern headers",
            "description": "Populate prism_temporal_ctx_t fields using parsed pattern metadata and verify motion init behavior.",
            "dependencies": [
              1
            ],
            "details": "Extract temporal mode, timing parameters, and motion metadata from the loaded .prism pattern header, cache the resulting prism_temporal_ctx_t on the playback descriptor, and validate the structure through prism_motion_init to catch invalid fields early.",
            "status": "pending",
            "testStrategy": "Create a mocked pattern header test confirming context fields match expected values and motion init rejects malformed data.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate calculate_ch2_frame with RMT flow",
            "description": "Invoke calculate_ch2_frame ahead of RMT transmission while respecting FreeRTOS synchronization needs.",
            "dependencies": [
              1,
              2
            ],
            "details": "Trigger calculate_ch2_frame() just before rmt_write_items(), gate the send path so the buffer is ready, and coordinate completion via rmt_wait_tx_done plus the existing ISR semaphore to avoid frame overlap.",
            "status": "pending",
            "testStrategy": "Use the playback regression harness to simulate successive frames and assert RMT writes observe updated ch2 buffer contents without timing violations.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement esp_timer driven frame timing",
            "description": "Track playback timestamps with esp_timer to compute accurate per-frame timing and handle reference updates.",
            "dependencies": [
              2,
              3
            ],
            "details": "Store pattern start ticks via esp_timer_get_time(), derive frame_time_ms each loop, and honor TLV set_reference commands by resetting the baseline so temporal calculations stay synchronized.",
            "status": "pending",
            "testStrategy": "Add an integration test that fakes esp_timer readings to confirm frame timing reacts to reference resets and produces expected deltas for the temporal calculator.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Plan subtasks for wiring context construction, channel buffering, motion switch scaffolding, demo pattern generation, and integration test/logging validation.",
        "updatedAt": "2025-10-16T08:45:12.012Z"
      },
      {
        "id": "15",
        "title": "Implement PROGRESSIVE Mode with Shape Presets",
        "description": "Add linear interpolation temporal delays enabling progressive shapes and provide preset pattern definitions.",
        "details": "Files: prism_temporal.c, new preset files under assets/presets/progressive/.\nSteps:\n1. Extend `calculate_ch2_frame()` to handle `SYNC_MODE_PROGRESSIVE` using formula `delay[i] = start_ms + ((end_ms - start_ms) * i) / 159` (precomputed into static array on pattern load).\n2. Support motion direction by swapping LED index iteration for LEFT vs RIGHT and mirroring for EDGE vs CENTER.\n3. Define shape preset generator helper:\n```\nstatic void prism_build_shape(shape_t type, uint16_t *start, uint16_t *end){\n    switch(type){\n        case SHAPE_RIGHT_TRIANGLE: *start=0; *end=200; break;\n        // etc.\n    }\n}\n```\n4. Produce 5 presets (right triangle, left triangle, diamond, chevron, gradient) with metadata stored in pattern repository.\n5. Ensure per-LED counters stored in `uint16_t progressive_delay_table[160]` within context (static allocation).",
        "testStrategy": "Unit tests validating interpolation endpoints, monotonicity for triangles, and symmetry for diamond; snapshot tests comparing generated preset delay tables against golden arrays.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement progressive ramp generator",
            "description": "Add a build_progressive_ramp helper that fills delay tables with linear interpolation math.",
            "dependencies": [],
            "details": "Use fixed-point int32_t math to compute delay[i] = start_ms + span * i / 159, writing into the static uint16_t progressive_delay_table[160] allocated in prism_temporal.c and enforce monotonic increase with guard checks.",
            "status": "pending",
            "testStrategy": "Add focused unit coverage that feeds known start/end pairs to validate endpoints, monotonicity, and overflow handling for build_progressive_ramp.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add motion direction handling to progressive frames",
            "description": "Update calculate_ch2_frame to respect LEFT/RIGHT direction and EDGE/CENTER mirroring when populating progressive delays.",
            "dependencies": [
              1
            ],
            "details": "Integrate direction flags so LEFT iterates LEDs 0→159, RIGHT iterates 159→0, and EDGE/CENTER patterns mirror indices around midpoint while reusing the populated progressive_delay_table values when emitting ch2 frames.",
            "status": "pending",
            "testStrategy": "Extend existing temporal tests to confirm direction swaps and mirroring yield expected index ordering for representative presets.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create prism_build_shape dispatcher",
            "description": "Introduce prism_build_shape that routes shape_t enums to specific preset builders and annotates pattern metadata.",
            "dependencies": [
              1
            ],
            "details": "Implement a switch-based dispatcher in prism_temporal.c that selects triangle, wedge, diamond, chevron, and gradient builders, populates start/end ranges via prism_build_shape helpers, and records direction flags for downstream rendering.",
            "status": "pending",
            "testStrategy": "Add lightweight dispatcher tests that mock shape_t inputs to confirm correct function pointers and metadata fields are selected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement triangle preset builder",
            "description": "Author the triangle preset builder producing symmetric progressive ramps with seamless midpoint transition.",
            "dependencies": [
              1,
              3
            ],
            "details": "Use build_progressive_ramp to generate a two-phase ramp: indices 0-79 ascend toward peak_ms and 80-159 descend while ensuring continuity at index 79/80, storing metadata for LEFT/RIGHT variants in assets/presets/progressive/triangle files.",
            "status": "pending",
            "testStrategy": "Create golden delay arrays verifying peak alignment and symmetry checks for triangle presets within the new unit test suite.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement wedge preset builder",
            "description": "Develop wedge preset preset generating edge-biased plateau shapes using the progressive delay table infrastructure.",
            "dependencies": [
              1,
              3
            ],
            "details": "Produce an ascending ramp up to a configurable plateau_index then fill remaining LEDs with end_ms values, supporting edge-biased peaks and exporting metadata for chevron, diamond, and gradient variants in preset assets.",
            "status": "pending",
            "testStrategy": "Capture golden outputs for representative wedge configurations and assert plateau sections remain constant while ramps stay monotonic.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add progressive temporal unit tests",
            "description": "Create test_prism_temporal_progressive.c covering ramp math, direction handling, and preset outputs using golden tables.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Author Unity tests that validate delay[0]==start_ms, delay[159]==end_ms, monotonic properties for ramps, symmetry for triangle/diamond presets, and compare generated tables against stored golden snapshots.",
            "status": "pending",
            "testStrategy": "Integrate the new test module into firmware tests and run it in CI to guard against regressions in interpolation, direction logic, and preset builders.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Define subtasks covering delay table generation, motion-direction handling, preset builders, static allocation management, firmware logic updates, and verification tests with goldens.",
        "updatedAt": "2025-10-16T08:42:21.657Z"
      },
      {
        "id": "16",
        "title": "Execute Progressive Mode Hardware Validation & Performance Profiling",
        "description": "Validate visual correctness of progressive shapes on hardware and capture performance data at 120 FPS.",
        "details": "Steps:\n1. Deploy firmware to three ESP32-S3 units attached to dual-edge LGP rig.\n2. Capture high-speed (240 FPS) video for each preset; extract frame-by-frame delay measurements using Python script + OpenCV to compute LED activation timing.\n3. Record observer feedback confirming phi phenomenon (triangles perceived smoothly).\n4. Use ESP-IDF `esp_timer` tracing to measure per-frame temporal compute time (<0.1% CPU budget) and generate profiling report.\n5. Store hardware photos and performance graphs in `docs/phase2/` and update ADR-010 appendix.\n6. File bug reports if any flicker or over-budget frames detected.",
        "testStrategy": "Review captured media vs expected shape outlines, compare timer logs against threshold, and run automated script ensuring frame variance <±5ms across LED indices.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Chronos 2.1 high-speed capture rig",
            "description": "Prepare Chronos 2.1 camera for 240 FPS progressive LED capture on the dual-edge rig.",
            "dependencies": [],
            "details": "Mount the camera on the rig, place calibration grid, set 240 FPS with 1/1000s shutter, balance lighting, and document lens and exposure parameters.",
            "status": "pending",
            "testStrategy": "Record a calibration clip and verify frame metadata plus grid alignment in review software.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Develop analyze_progressive.py timing extractor",
            "description": "Implement OpenCV timing analyzer for progressive LED activation footage.",
            "dependencies": [
              1
            ],
            "details": "Build analyze_progressive.py to load Chronos videos, segment LED regions, track luminance per frame, calculate activation latency, and output CSV summaries with plots.",
            "status": "pending",
            "testStrategy": "Run the script on the calibration capture and confirm CSV latency traces match expected sequencing.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Conduct phi phenomenon observer trials",
            "description": "Run observer validation sessions to confirm smooth progressive motion perception.",
            "dependencies": [
              1,
              2
            ],
            "details": "Recruit 3-5 testers, brief them on rating scales, play processed sequences at 120 FPS, capture 60-150 ms smoothness ratings, and log qualitative comments.",
            "status": "pending",
            "testStrategy": "Collect signed observation forms and check all ratings meet the acceptance threshold without missing entries.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Instrument firmware with esp_timer profiling",
            "description": "Add esp_timer-based profiling hooks to measure progressive mode CPU usage.",
            "dependencies": [
              1
            ],
            "details": "Wrap progressive rendering routines with esp_timer_get_time, aggregate microsecond timings, guard with config flag, and ensure compute budget stays under 0.1 percent CPU.",
            "status": "pending",
            "testStrategy": "Flash instrumented firmware and review serial logs confirming per-frame averages remain within the CPU budget.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Execute visual shape verification analytics",
            "description": "Quantify shape fidelity using jitter and CAD overlay comparisons.",
            "dependencies": [
              2,
              4
            ],
            "details": "Post-process LED timing data to compute RMS deviations versus CAD overlays, measure peak-to-peak jitter, and generate visual reports comparing expected and observed shapes.",
            "status": "pending",
            "testStrategy": "Automate the analytics routine to flag deviations beyond ±5 ms or geometry limits and validate on a sample dataset.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Archive validation artifacts and update Task Master records",
            "description": "Consolidate validation outputs and document results in project systems.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Store CSVs, videos, observer notes, profiling logs, and graphs under docs/phase2/, update ADR-010 appendix, and link artifacts within Task Master entries.",
            "status": "pending",
            "testStrategy": "Confirm repository updates include new docs paths and Task Master references to each archived artifact.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Outline subtasks for firmware deployment, high-speed capture workflow, quantitative analysis scripts, performance logging, documentation updates, and bug triage/reporting.",
        "updatedAt": "2025-10-16T08:42:22.333Z"
      },
      {
        "id": "17",
        "title": "Add WAVE Mode with Lookup Tables",
        "description": "Introduce WAVE sync mode using precomputed delay lookup tables and generate sine, triangle, and sawtooth presets.",
        "details": "Files: prism_temporal.c, new module `firmware/components/playback/wave_lut.c`.\nSteps:\n1. Create lookup generator `void prism_wave_build_table(waveform_t type, uint16_t amplitude_ms, uint16_t frequency_fp8, uint16_t phase_deg, uint16_t *out_table)` producing 160 entries.\n2. Precompute tables on pattern load (effect start) storing in static `uint16_t wave_delay_table[160]`.\n3. Implement WAVE branch in `calculate_ch2_frame()` fetching `delay = wave_delay_table[index];` and applying motion direction transforms.\n4. Inline hot-path helpers with `static inline` or `ESP_FORCE_INLINE` to cut call overhead.\n5. Create presets for sine, sawtooth, triangle waves with amplitude/frequency param sets aligned to spec.\nPseudo-code:\n```\nfor i in 0..159:\n    float theta = (i / 160.0f) * 2π * frequency + phase;\n    switch(type){\n        case SINE: delay[i] = base + amplitude * (sin_table[theta_fp] + 1)/2;\n        ...\n    }\n```\n6. Ensure tables use ADR-009 sin8() for fixed-point math (no floating point in render loop).",
        "testStrategy": "Unit tests ensuring LUT generation matches expected waveform math, verifying execution time <0.5µs using cycle counter, and checking presets produce correct amplitude extrema.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Build wave LUT generator module",
            "description": "Implement the prism_wave_build_table function to emit 160-entry fixed-point lookup tables.",
            "dependencies": [],
            "details": "Create firmware/components/playback/wave_lut.c and header defining waveform_t enum usage, implement prism_wave_build_table using ADR-009 sin8() helpers, fixed-point arithmetic, and ESP_FORCE_INLINE utility helpers.",
            "status": "pending",
            "testStrategy": "Add unit coverage in test_wave_lut.c comparing generated sine and triangle tables against precalculated fixtures for multiple amplitudes and phases.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Precompute wave delay table on pattern load",
            "description": "Integrate table allocation and generation during pattern initialization to populate the static cache.",
            "dependencies": [
              1
            ],
            "details": "Extend prism_temporal.c pattern load path to declare static uint16_t wave_delay_table[160], invoke prism_wave_build_table with current sync parameters, and ensure memory lifetime spans effect duration while guarding against re-entry.",
            "status": "pending",
            "testStrategy": "Add integration test in test_prism_temporal.c verifying wave_delay_table populates with non-zero values after mock pattern load and that repeated loads refresh contents.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add WAVE branch to calculate_ch2_frame",
            "description": "Update the temporal rendering loop to consume the precomputed wave table for delay selection.",
            "dependencies": [
              2
            ],
            "details": "Modify calculate_ch2_frame() to recognize sync mode WAVE, compute table index from frame counter, fetch delay from wave_delay_table, and maintain existing behavior for other modes.",
            "status": "pending",
            "testStrategy": "Extend temporal loop unit tests to assert WAVE mode reads expected indices and preserves baseline behavior for SYNC/PROGRESSIVE paths.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement motion direction transforms for WAVE mode",
            "description": "Apply motion-direction-specific adjustments to wave-based delays using inlined helpers.",
            "dependencies": [
              3
            ],
            "details": "Introduce static inline helpers in prism_temporal.c mapping wave_delay_table outputs through LEFT/RIGHT/CENTER/EDGE/STANDARD transforms, leveraging ESP_FORCE_INLINE where needed to avoid call overhead.",
            "status": "pending",
            "testStrategy": "Add focused tests verifying each motion direction produces expected mirrored or shifted indices, plus review assembly output to confirm helpers inline.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create sine, triangle, sawtooth presets",
            "description": "Define preset parameter sets and hook them into the effect pipeline.",
            "dependencies": [
              4
            ],
            "details": "Implement preset factory routines selecting waveform type, amplitude, frequency, and phase per spec, wire into pattern loader so WAVE mode selects presets by name, and document options in playback headers.",
            "status": "pending",
            "testStrategy": "Add preset unit tests ensuring each preset yields expected min/max delay extremes and correct waveform type routing.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add LUT regression and performance tests",
            "description": "Validate waveform accuracy and execution timing for the completed WAVE implementation.",
            "dependencies": [
              5
            ],
            "details": "Author regression tests comparing generated tables against golden vectors, integrate cycle-counter measurement to assert calculate_ch2_frame WAVE path stays under 0.5µs, and include basic fuzz inputs for amplitude/frequency bounds.",
            "status": "pending",
            "testStrategy": "Extend Unity harness with timing assertions using esp_clk_cpu_freq(), run tests under CI profile, and capture perf metrics for documentation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Split into subtasks for LUT generator module, table allocation/loading, calculate_ch2_frame wave branch, motion transforms, preset creation, and unit/perf testing.",
        "updatedAt": "2025-10-16T08:37:04.824Z"
      },
      {
        "id": "18",
        "title": "Profile and Optimize WAVE Mode Execution",
        "description": "Benchmark LUT vs realtime sinusoid calculations and ensure CPU utilization remains within budget.",
        "details": "Steps:\n1. Implement profiling hooks toggled via `CONFIG_PRISM_PROFILE_TEMPORAL` measuring cycle counts for LUT lookup vs `sinf` baseline.\n2. Compare average runtime across 10k frames, target reduction from ~80µs to <1µs.\n3. Document cache effects: ensure tables placed in DRAM with `DRAM_ATTR` to avoid flash latency.\n4. Validate no heap fragmentation by inspecting `heap_caps_get_free_size(MALLOC_CAP_8BIT)` before/after wave mode run.\n5. Publish report `docs/phase3/wave_performance.md` with table of results and optimization notes.",
        "testStrategy": "Automated profiling test harness asserting LUT path <1µs median runtime, verifying no heap usage via custom allocator hooks, and ensuring wave visuals remain artifact-free under 120 FPS playback in simulation.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Enable CONFIG_PRISM_PROFILE_TEMPORAL profiling framework",
            "description": "Add the configurable profiling framework for wave mode so temporal hooks can be toggled at build time.",
            "dependencies": [],
            "details": "Define CONFIG_PRISM_PROFILE_TEMPORAL in Kconfig, add wave_profiler_begin/end inline helpers, and schedule a ring-buffer drain task that writes CSV rows to /spiffs/profile_wave.csv.",
            "status": "done",
            "testStrategy": "Toggle the config in idf.py menuconfig and confirm the CSV writer task emits entries during a simulated wave run.",
            "parentId": "undefined",
            "updatedAt": "2025-10-16T08:38:12.667Z"
          },
          {
            "id": 2,
            "title": "Instrument wave execution with esp_cpu_get_cycle_count",
            "description": "Capture precise cycle counts for LUT and sinf paths to compare execution cost.",
            "dependencies": [
              1
            ],
            "details": "Wrap wave sections with portENTER_CRITICAL/portEXIT_CRITICAL, invoke esp_cpu_get_cycle_count with rollover handling, convert cycles to nanoseconds, and pin the profiler task to core 0.",
            "status": "done",
            "testStrategy": "Run the profiler under load and verify cycle deltas remain stable across iterations and that rollover logic preserves monotonic timings.",
            "parentId": "undefined",
            "updatedAt": "2025-10-16T08:38:14.078Z"
          },
          {
            "id": 3,
            "title": "Integrate Xtensa PMU cache profiling and DRAM audits",
            "description": "Measure cache behavior and ensure lookup tables stay in DRAM to avoid flash latency.",
            "dependencies": [
              1,
              2
            ],
            "details": "Configure perfmon_config_t for PM_CYCLES and PM_DCACHE_MISS, log miss ratios alongside timings, and validate DRAM_ATTR placement and 64-byte alignment via build/prism.map inspection.",
            "status": "done",
            "testStrategy": "Enable PMU counters during the profiling run and confirm logged miss counts drop when DRAM_ATTR placement is correct.",
            "parentId": "undefined",
            "updatedAt": "2025-10-16T08:38:49.734Z"
          },
          {
            "id": 4,
            "title": "Optimize LUT access path for wave mode",
            "description": "Refine the LUT code path to minimize instruction count and memory stalls.",
            "dependencies": [
              2,
              3
            ],
            "details": "Introduce branchless phase-to-index masking, apply ESP_FORCE_INLINE to phase helpers, locate hot kernels in IRAM_ATTR, and store a 1024-entry sin8 table in DRAM.",
            "status": "done",
            "testStrategy": "Benchmark the optimized LUT path against the baseline and confirm the median runtime approaches the <1µs target.",
            "parentId": "undefined",
            "updatedAt": "2025-10-16T08:38:50.506Z"
          },
          {
            "id": 5,
            "title": "Build wave profiling harness and generate validation artifacts",
            "description": "Create the automated harness to validate performance, heap health, and reporting outputs.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement tests/profile_wave_mode.c to run 10k frames, emit JSON results to .taskmaster/reports/, assert median runtime <1µs, and check heap_caps_get_minimum_free_size for fragmentation.",
            "status": "done",
            "testStrategy": "Execute the harness on hardware, review JSON output for pass criteria, and ensure heap metrics remain unchanged pre/post run.",
            "parentId": "undefined",
            "updatedAt": "2025-10-16T08:38:51.292Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Create subtasks for profiling hook implementation, benchmark harness, memory placement audits, heap diagnostics, and report generation with recommendations.",
        "updatedAt": "2025-10-16T08:38:51.292Z"
      },
      {
        "id": "19",
        "title": "Implement CUSTOM Mode and Web-Based Delay Map Editor",
        "description": "Deliver CUSTOM sync mode with arbitrary delay maps and a web editor for authoring .prism v1.1 patterns.",
        "details": "Steps:\n1. Extend `calculate_ch2_frame()` for CUSTOM mode loading 320-byte delay map into static array `custom_delay_map[160]` and reading per LED.\n2. Add validation during pattern upload ensuring delay range 0-500ms and map size correct; reject invalid TLVs.\n3. Build web editor (React or Svelte per existing stack) in `tools/custom-delay-editor/` with:\n   - Canvas preview of 160 LEDs (top/bottom channels).\n   - Drag control points generating cubic spline curve mapped to delay values.\n   - Import/export `.prism` via WebUSB or file download.\n4. Implement export pipeline: serialize header + delay map using WebAssembly helper reusing existing C structs compiled via Emscripten.\n5. Seed preset library with triangle/diamond/wave templates.\nPseudo-code (CUSTOM evaluation):\n```\nfor i in 0..159:\n    uint16_t delay = custom_delay_map[i];\n    if (frame_elapsed_ms < delay) ch2[i] = 0;\n    else ch2[i] = ch1[i];\n```\n6. Provide documentation `docs/phase4/custom_mode.md` describing workflow.",
        "testStrategy": "Unit tests for delay map parsing, web editor Jest tests validating curve-to-delay conversion, end-to-end test exporting pattern and verifying firmware playback matches authored delay map using hardware loopback harness.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up WebAssembly serializer build",
            "description": "Establish the emscripten build pipeline for the shared .prism serializer module.",
            "dependencies": [],
            "details": "Create emcc configuration, integrate existing C structs, and produce reusable WASM/JS glue exposing serialization APIs for the web tool.",
            "status": "pending",
            "testStrategy": "Add CI step invoking emcc build and verify exported functions via wasm-smoke tests.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement spline-based curve editor UI",
            "description": "Build interactive curve editor interface supporting control point manipulation.",
            "dependencies": [
              1
            ],
            "details": "Use existing frontend stack to create canvas UI with draggable Bezier/spline handles, dual-channel LED layout, and state management for 160-point curve authoring.",
            "status": "pending",
            "testStrategy": "Jest + React Testing Library checks for control point interactions and state persistence.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create curve-to-delay sampling engine",
            "description": "Convert authored curves into 160 delay samples between 0 and 500 ms.",
            "dependencies": [
              2
            ],
            "details": "Implement sampling routine that evaluates spline geometry, clamps values within allowed bounds, and outputs 320-byte delay map ready for firmware consumption.",
            "status": "pending",
            "testStrategy": "Unit tests comparing sampled arrays against analytic references and boundary conditions.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add firmware delay map validation",
            "description": "Extend firmware upload validation for CUSTOM delay maps and constraints.",
            "dependencies": [
              3
            ],
            "details": "Update pattern ingestion to enforce TLV size of 320 bytes, validate each delay within 0-500 ms, and reject malformed payloads before storage.",
            "status": "pending",
            "testStrategy": "Unity tests feeding valid/invalid TLVs verifying acceptance, rejection codes, and error logging.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement real-time LED preview renderer",
            "description": "Render dual-channel LED preview reflecting sampled delays in the browser.",
            "dependencies": [
              3
            ],
            "details": "Build WebGL or Canvas2D renderer that simulates top/bottom LED playback using incoming ch1 data and computed ch2 delays for live visualization.",
            "status": "pending",
            "testStrategy": "Visual regression via Jest canvas snapshots and manual QA checklist for playback timing.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": ".prism export and TLV integration",
            "description": "Wire WebAssembly serializer into export flow for .prism files.",
            "dependencies": [
              1,
              3,
              5
            ],
            "details": "Connect sampling output to WASM serializer, package header and delay map into TLV-compliant .prism payload, and support WebUSB download/upload flows.",
            "status": "pending",
            "testStrategy": "End-to-end browser tests verifying generated files load in firmware harness and pass TLV checks.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Seed preset library with CUSTOM patterns",
            "description": "Author preset delay maps (triangle, diamond, wave) leveraging prior tasks.",
            "dependencies": [
              3,
              6
            ],
            "details": "Use curve editor and serialization path to create preset JSON/.prism assets, cross-reference Task 15 shapes, and register them in preset catalog.",
            "status": "pending",
            "testStrategy": "Snapshot tests ensuring preset delay arrays match expected shapes and metadata integrity checks.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Build comprehensive CUSTOM mode test suite",
            "description": "Develop automated tests covering web tool, serialization, and firmware integration.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Expand Jest suites for UI/sampling, add integration tests for export/import, and create Unity firmware tests validating runtime playback with seeded presets.",
            "status": "pending",
            "testStrategy": "Run combined Jest suite and Unity hardware-in-the-loop regression verifying outputs align with reference delay maps.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Plan subtasks spanning firmware support for custom maps, validation logic, web editor UI/UX, curve-to-delay algorithms, import/export tooling, WASM glue, preset seeding, and documentation/tests.",
        "updatedAt": "2025-10-16T09:01:10.918Z"
      },
      {
        "id": "20",
        "title": "Finalize Documentation, Migration, and Release Validation",
        "description": "Finalize firmware v1.1 deliverables by leveraging the finished migration CLI and user manual to complete media assets, long-run validation, preset packaging, and the public release handoff.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "medium",
        "details": "Steps:\n1. Completed: Ship the `tools/prism-migrate` CLI converting v1.0 patterns to v1.1 with default motion/sync metadata and idempotent re-runs.\n2. Completed: Publish the user manual and tutorials set in `docs/user-manual/`, covering temporal sequencing, motion directions, sync modes, and advanced techniques.\n3. Produce five narrated 10–15 minute tutorial videos capturing screen and hardware demos, then upload to YouTube and link from the README.\n4. Conduct the 24-hour soak test cycling 20+ presets on at least three hardware units with telemetry for heap fragmentation (<5%), frame timings, and thermals.\n5. Assemble and package a ≥20 pattern preset library that exercises all motion and sync combinations alongside metadata defaults.\n6. Extend the updated `CHANGELOG.md` and local `firmware-v1.1` tag into polished release notes that summarize validation evidence, link multimedia assets, and outline migration steps.\n7. Publish the v1.1 release by distributing artifacts, confirming OTA upgrades on three units, verifying rollback procedure, and archiving the complete asset bundle.",
        "testStrategy": "Confirm migration CLI regression logs remain green, re-review the published manual against the PRD checklist, validate tutorial videos for audio/visual quality and working README links, analyze soak test telemetry for zero frame drops and acceptable temperature margins, spot-check the preset library on hardware, and verify final release artifacts (including CHANGELOG updates and tag) pass the QA checklist before publication.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement v1.0→v1.1 migration CLI",
            "description": "Create the `tools/prism-migrate` CLI to upgrade legacy pattern packs to firmware v1.1 format.",
            "dependencies": [],
            "details": "Build parser for v1.0 headers, enforce CRC validation, inject default motion and sync metadata, and ensure repeated runs remain idempotent.",
            "status": "done",
            "testStrategy": "Add regression suite comparing source and migrated pattern CRCs and verifying metadata defaults.','parentId':'undefined'",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Write comprehensive user manual",
            "description": "Author Markdown documentation covering firmware v1.1 concepts and workflows.",
            "dependencies": [],
            "details": "Organize docs in `docs/user-manual/`, explain temporal sequencing, motion directions, sync modes, advanced techniques, and include phi phenomenon discussion.",
            "status": "done",
            "testStrategy": "Peer review against PRD checklist and lint Markdown for broken links.','parentId':'undefined'",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Produce five narrated tutorial videos",
            "description": "Develop and publish 10-15 minute instructional videos for firmware v1.1.",
            "dependencies": [
              2
            ],
            "details": "Draft scripts, capture screen plus hardware demos, record narration, edit, upload to YouTube, and add links to README.",
            "status": "pending",
            "testStrategy": "Review audio/video quality checklist and confirm published links play end-to-end.','parentId':'undefined'",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Set up 24-hour soak test infrastructure",
            "description": "Prepare automation and hardware to run extended stability testing.",
            "dependencies": [
              1
            ],
            "details": "Provision three test units, script pattern cycling over 20+ presets, enable telemetry capture for heap usage, frame timing, and thermal logging.",
            "status": "pending",
            "testStrategy": "Dry-run automation for one hour verifying telemetry files generate correctly.','parentId':'undefined'",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Execute soak test and analyze telemetry",
            "description": "Run long-duration test and compile stability findings.",
            "dependencies": [
              4
            ],
            "details": "Execute 24-hour run, collect logs, analyze heap fragmentation, frame drops, and thermal trends, then summarize results in report.",
            "status": "pending",
            "testStrategy": "Validate analysis scripts with spot checks and confirm report includes required metrics.','parentId':'undefined'",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Assemble pattern preset library",
            "description": "Curate and package patterns showcasing all mode combinations.",
            "dependencies": [
              1
            ],
            "details": "Design 20+ presets as `.prism` files with metadata covering motion and sync permutations, bundle artifacts with release package.",
            "status": "pending",
            "testStrategy": "Load presets on hardware to verify metadata recognition and playback quality.','parentId':'undefined'",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Draft production release notes",
            "description": "Document firmware v1.1 changes and migration guidance.",
            "dependencies": [
              1,
              5,
              6
            ],
            "details": "Roll forward the updated `CHANGELOG.md`, incorporate soak-test findings, highlight breaking changes, and reference validation evidence plus multimedia links.",
            "status": "pending",
            "testStrategy": "Cross-check notes against completed work and run Markdown link checker.','parentId':'undefined'",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Deploy v1.1 firmware and validate release",
            "description": "Publish artifacts and confirm rollout on target hardware.",
            "dependencies": [
              5,
              6,
              7
            ],
            "details": "Convert the local `firmware-v1.1` tag into the public release, distribute firmware, perform OTA updates on three units, verify rollback procedure, and archive all release assets.",
            "status": "pending",
            "testStrategy": "Execute upgrade/rollback smoke tests on each unit and verify checksums of published artifacts.','parentId':'undefined'",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Break into subtasks for migration CLI, user manual authoring, tutorial production, soak testing plus telemetry analysis, pattern library packaging, release notes, QA checklist, and artifact publication."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-16T09:01:10.919Z",
      "taskCount": 20,
      "completedCount": 15,
      "tags": [
        "master"
      ]
    }
  }
}