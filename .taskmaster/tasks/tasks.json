{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Establish Node Graph State Management",
        "description": "Design the minimal Zustand-backed graph state slice for nodes, pins, and params while matching the undo/redo plus autosave conventions seen in `studio/src/stores/project.ts` (temporal + markDirty/touch) and the leaner `studio/src/stores/timeline.ts` patterns. Extend scope to include NodeDefinitions-based validation and standalone graph selectors. Use zundo temporal with limit 50, partialized to `graph`, and revision-based equality; export a `withHistoryBatch` helper for gesture grouping.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Codebase alignment and targets (based on repo scan):\n- Stores: `studio/src/stores/project.ts`, `studio/src/stores/device.ts`, and `studio/src/stores/timeline.ts` compose `devtools` + `immer`; `project.ts`/`device.ts` use `zundo` temporal with `limit: 50`, partialized history, and identity equality; exports undo/redo via `useXxxStore.temporal.getState()` (see device export names `deviceUndo/deviceRedo/deviceHistoryClear`).\n- Persistence: `studio/src/lib/projectSchema.ts` currently has no `graph` field; `createEmptyProject` lives here; `serializeProject`/`deserializeProject` are in `studio/src/stores/project.ts`.\n- Vitest setup: `studio/vitest.config.ts` uses `happy-dom`; test files match `src/**/*.test.{ts,tsx}`; see patterns in `studio/src/stores/{project,device}.test.ts`.\n\nStore implementation (zustand + immer + zundo temporal):\n- Add `studio/src/stores/graph.ts` using `create`, `devtools`, `immer`, and `temporal`, mirroring composition in `project.ts`/`device.ts`.\n- Types and shape:\n  - `type NodeKind = 'Noise2D' | 'Gradient' | 'Solid' | 'Rotate' | 'Scale' | 'Mirror' | 'Add' | 'Multiply' | 'PaletteMap' | 'HueShift' | 'Brightness' | 'ToK1'`.\n  - `type ParamValue = number | string`.\n  - `interface GraphNode { id: string; kind: NodeKind; params: Record<string, ParamValue>; inputs: Record<string, string | null>; }`.\n  - `type Graph = { nodes: Record<string, GraphNode>; order: string[]; revision: number; outputGeometry?: { width: number; height: number } }`.\n  - UI slice excluded from history/persistence: `{ layout: Record<string, { x: number; y: number }>; selection: string[] }`.\n- Temporal configuration (update vs. earlier referential plan):\n  - `temporal(immer(...), { limit: 50, partialize: (s) => ({ graph: s.graph }), equality: (a, b) => (a as any).graph?.revision === (b as any).graph?.revision })`.\n  - Rationale: revision-based equality drops redundant frames and formalizes gesture grouping; keep UI-only edits out of history by default.\n- Autosave coupling: do NOT add autosave in graph store; for each mutating action, call `useProjectStore.getState().touch()` (see `studio/src/stores/project.ts` for the hybrid throttle pattern with idle flush and edit thresholds).\n- Actions (all increment `graph.revision` and call `touch()`):\n  - `addNode(node, pos?)`, `removeNode(id)` (clean inbound references), `updateNodeParams(id, key, value)`, `connectPins(toNodeId, toPin, fromNodeId)`, `setOutputGeometry(geometry)`.\n  - `connectPins` must validate nodes and pins, prevent self-loops, and reject cycles via a cheap dependsOn DFS over `inputs`.\n- Exports:\n  - Undo/redo/clear (and pause/resume): `export const { undo: graphUndo, redo: graphRedo, clear: graphHistoryClear, pause: graphHistoryPause, resume: graphHistoryResume } = (useGraphStore as any).temporal.getState();` (matches style in `studio/src/stores/device.ts`).\n  - `withHistoryBatch(fn)`: helper that `pause()`/`resume()` around a function body to coalesce multi-step gestures into one history frame.\n\nNodeDefinitions & validation (new):\n- Add `studio/src/lib/graph/nodeDefinitions.ts` exporting per-`NodeKind` definitions:\n  - For each kind specify: `inputs: Record<string, { required?: boolean; arity?: 1 | 'many' }>` and `params: Record<string, { type: 'number' | 'string' | 'color'; min?: number; max?: number; enum?: string[] }>`.\n- Enforce in graph actions:\n  - `connectPins`: check target node exists; check `toPin` exists per definition; ensure arity constraints; prevent self-connect; run cycle precheck; error codes: `NODE_NOT_FOUND`, `PIN_NOT_FOUND`, `CYCLE`.\n  - `updateNodeParams`: verify param key exists and value matches type/range; error codes: `TYPE_INVALID`, `RANGE_INVALID`.\n  - Emit errors as `throw new Error(<CODE>)` (consistent with `NO_DEVICE` error usage in `studio/src/stores/device.ts`).\n\nSelectors & topology (new):\n- Add `studio/src/stores/graph.selectors.ts` exporting pure utilities that operate on `{ nodes, order }`:\n  - `orderedNodes(graph): GraphNode[]` (map `order` to nodes).\n  - `getEdges(graph): Array<{ from: string; to: string; pin: string }>` (from each node.inputs mapping).\n  - `topoSort(graph): string[]` (throws on cycles; second backstop to `connectPins` precheck).\n  - `canConnect(state, toNodeId, toPin, fromNodeId): { ok: true } | { ok: false; code: 'NODE_NOT_FOUND' | 'PIN_NOT_FOUND' | 'CYCLE' }` (uses NodeDefinitions + DFS).\n- Document gesture grouping policy: UI-only actions (`setNodePosition`, `setSelection`) are excluded from history; for drag gestures that should record once, use `withHistoryBatch` or temporal `pause()` on pointerdown and `resume()` on pointerup.\n\nProject schema and persistence:\n- Extend `studio/src/lib/projectSchema.ts` with a `GraphSchema` matching the Graph shape above, and add `graph: GraphSchema.default(/* Solid → ToK1 seed */)` to `ProjectSchema`.\n- Update `createEmptyProject` to include a seeded graph default: nodes `{ nSolid: { kind: 'Solid', params: { color: '#ffffff' }, inputs: {} }, nToK1: { kind: 'ToK1', params: {}, inputs: { input: 'nSolid' } } }`, `order: ['nSolid','nToK1']`, `revision: 0`.\n- `serializeProject`/`deserializeProject` in `studio/src/stores/project.ts` already round-trip arbitrary fields; older projects parse via GraphSchema defaults.\n\nBenchmarks:\n- Add `studio/src/stores/graph.bench.test.ts` to run ~1,000 mixed ops across graph sizes 25/100/500; mix ~600 param edits, ~200 connect/disconnects, ~200 add/remove pairs; measure total apply/undo/redo times with autosave stubbed (spy on `useProjectStore.getState().touch()`); initial targets ≤2.5s for apply/undo/redo each on typical dev hardware; memory delta ~20–40 MB for N≈100 with limit 50.\n\nAcceptance and risks:\n- Composition matches stores; history partialized to `graph` with `limit: 50` and revision-based equality; required actions exist and call `touch()`; undo/redo work; UI-only edits excluded from history; project schema persists a seeded Solid → ToK1 graph; older projects load with defaults. Risks (snapshot memory/latency, history flooding) mitigated via partialize, modest limit, and grouping; cycle checks via DFS and `topoSort` backstop; autosave duplication avoided by relying on `project.ts` autosave.\n",
        "testStrategy": "- Unit tests: add `studio/src/stores/graph.test.ts` (mirroring `project.test.ts`/`device.test.ts`) covering:\n  - Default seeding (Solid → ToK1 graph) from `createEmptyProject` in `studio/src/lib/projectSchema.ts`.\n  - CRUD flows with guards (duplicate id, not found); `removeNode` cleans inbound references.\n  - Pin wiring with cycle prevention; `canConnect` error-paths.\n  - NodeDefinitions validation: invalid connect emits `NODE_NOT_FOUND`/`PIN_NOT_FOUND`/`CYCLE`; invalid params emit `TYPE_INVALID`/`RANGE_INVALID`.\n  - Undo/redo via `useGraphStore.temporal.getState().undo/redo` and ensure UI-only actions are not recorded.\n  - Autosave coupling: spy on `useProjectStore.getState().touch()` in each mutating action.\n  - Serialization round-trip through `serializeProject`/`deserializeProject` with graph preserved.\n  - Selectors exported from `studio/src/stores/graph.selectors.ts` (`topoSort`, `getEdges`, `canConnect`) and behave as expected.\n- Benchmarks: `studio/src/stores/graph.bench.test.ts` executes the 1k mixed-op suite; set thresholds (apply/undo/redo ≤ 2.5s); stub autosave to avoid I/O skew.\n- Equality policy: a small test asserts history frames advance only when `graph.revision` increments; UI-only edits do not increment revision and therefore do not produce frames.\n",
        "subtasks": [
          {
            "id": 1,
            "title": "Review existing Zustand store patterns",
            "description": "Inspect current store implementations to capture structure and conventions.",
            "dependencies": [],
            "details": "Read `studio/src/stores/project.ts`, `studio/src/stores/device.ts`, and `studio/src/stores/timeline.ts` to catalog `devtools`/`immer` composition, `temporal` wiring, the `markDirty`/`touch` autosave helper, and how selectors/exports like `serializeProject` and `undo` are surfaced for consumers.",
            "status": "pending",
            "testStrategy": "Capture findings in notes; no automated tests required.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define graph state contract",
            "description": "Design types and selectors for the new graph store slice.",
            "dependencies": [
              1
            ],
            "details": "Draft the NodeKind union, GraphNode interfaces, graph metadata, and selectors mirroring the naming used in `project.ts`. Summarize trade-offs between `zundo`'s `temporal` middleware and a custom temporal helper (see `docs/research/PRISM_Studio_Architecture_Research.md`) and decide which undo/redo surface the store will expose alongside serialization helpers.",
            "status": "pending",
            "testStrategy": "Peer review design notes or shared type definitions before implementation, ensuring the undo/redo API and serialization plan are documented.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement graph store with undo support",
            "description": "Build the Zustand store using immer and zundo hooks.",
            "dependencies": [
              2
            ],
            "details": "Create `studio/src/stores/graph.ts` implementing the agreed contract, composing `devtools`, `immer`, and the chosen temporal middleware for undo/redo/history configuration. Implement actions (`addNode`, `updateNodeParams`, `connectPins`, `removeNode`, `setOutputGeometry`), wire selectors, and ensure each mutation invokes `useProjectStore.getState().touch()` so autosave reuse matches the `markDirty` pattern in `project.ts`. Export undo/redo helpers consistent with other stores.",
            "status": "pending",
            "testStrategy": "Run the existing unit suite locally and add temporary smoke calls ensuring the graph store exports compile and temporal history mutators behave as expected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Extend project schema and defaults",
            "description": "Wire graph state into persistence and migrations.",
            "dependencies": [
              3
            ],
            "details": "Update `studio/src/lib/projectSchema.ts` to add the graph shape and migration defaults, seed `createEmptyProject` with a Solid → ToK1 starter graph, and ensure `serializeProject`/`deserializeProject` in `studio/src/stores/project.ts` handle the new field while tolerating payloads without `graph`. Keep migrations backward compatible.",
            "status": "pending",
            "testStrategy": "Run schema validation utilities (e.g., existing Vitest suites) to confirm legacy fixtures deserialize and new projects include the seeded graph.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Author graph store Vitest coverage",
            "description": "Add unit tests verifying store behaviors and serialization.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create `studio/src/stores/graph.test.ts` covering default state seeding, CRUD flows, pin connection validation, undo/redo via the chosen temporal API, and serialization round-trips through `serializeProject`/`deserializeProject`. Mirror `project.test.ts` and `device.test.ts` patterns to reset store state and spy on the project store `touch` helper.",
            "status": "pending",
            "testStrategy": "Execute the Vitest suite and confirm the new tests cover the specified scenarios, including undo/redo and autosave touch assertions.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Smoke-test project autosave integration",
            "description": "Verify graph changes persist and autosave triggers correctly.",
            "dependencies": [
              4,
              5
            ],
            "details": "Use the graph store actions to mutate nodes and confirm `useProjectStore.getState().touch()` fires, driving the autosave throttle from `project.ts` while persisting graph data via `serializeProject`/`deserializeProject`. Validate persistence by saving/loading a project and confirming the graph state survives reloads.",
            "status": "pending",
            "testStrategy": "Run the app smoke script or a manual session to confirm autosave writes updated graph state and that reloaded projects restore the graph as expected.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Add NodeDefinitions and connect/param validation",
            "description": "Define NodeDefinitions per NodeKind and enforce validation in graph actions.",
            "dependencies": [
              3
            ],
            "details": "Create `studio/src/lib/graph/nodeDefinitions.ts` with per-`NodeKind` specs (input pins with arity and param keys/types/ranges). Update `connectPins` and `updateNodeParams` in `studio/src/stores/graph.ts` to enforce definitions and emit error codes via thrown `Error`: `NODE_NOT_FOUND`, `PIN_NOT_FOUND`, `TYPE_INVALID`, `RANGE_INVALID`, `CYCLE`. Ensure `removeNode` cleans inbound references. Update tests accordingly in `studio/src/stores/graph.test.ts`.",
            "status": "pending",
            "testStrategy": "Acceptance: Invalid connect/param paths are rejected; each error code is covered by a dedicated unit test asserting the thrown message equals the code; valid paths succeed. Include cycle-case tests for both `connectPins` precheck and `topoSort` backstop.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Add graph selectors and temporal equality policy",
            "description": "Provide standalone selectors and switch temporal equality to revision-based, with a history batching helper.",
            "dependencies": [
              3
            ],
            "details": "Add `studio/src/stores/graph.selectors.ts` exporting `topoSort`, `getEdges`, and `canConnect` (using NodeDefinitions). Update `studio/src/stores/graph.ts` to use revision-based temporal equality and export `withHistoryBatch` plus direct `pause/resume` from temporal for gesture grouping. Document policy in code comments and ensure UI-only actions remain excluded from history.",
            "status": "pending",
            "testStrategy": "Acceptance: Selectors are exported and unit-tested; temporal equality compares `graph.revision`; `withHistoryBatch` exists and a test asserts grouped changes yield a single history frame; gesture grouping policy is documented in `graph.ts` comments.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Implement `studio/src/stores/graph.ts` using `create` + `devtools` + `immer` + `temporal` mirroring `useProjectStore` and `useDeviceStore`. Define `NodeKind`, `ParamValue`, `GraphNode`, `Graph`, and a UI slice excluded from history. Configure zundo with `{ limit: 50, partialize: (s)=>({ graph: s.graph }), equality: (a,b)=>(a as any).graph === (b as any).graph }`. Add actions: `addNode(node, pos?)`, `removeNode(id)`, `updateNodeParams(id,key,value)`, `connectPins(toNodeId,toPin,fromNodeId)` (with self-loop and cycle DFS guard), `setOutputGeometry(geometry)`. Every mutating action increments `graph.revision` and calls `useProjectStore.getState().touch()`. Export `graphUndo`, `graphRedo`, `graphHistoryClear` from `useGraphStore.temporal.getState()`. Extend `studio/src/lib/projectSchema.ts` with `GraphSchema` and add `graph` default in `createEmptyProject` (seed Solid → ToK1). Add `studio/src/stores/graph.test.ts` (undo/redo, pin wiring, autosave touch spy, serialization round-trip) and `studio/src/stores/graph.bench.test.ts` (1k mixed ops, undo/redo timing).",
        "updatedAt": "2025-10-17T10:17:14.853Z"
      },
      {
        "id": "2",
        "title": "Build Visual Node Graph Editor",
        "description": "Implement a React authoring surface for creating and wiring the tiny node set.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Add `studio/src/features/graph/GraphCanvas.tsx` and supporting components that render draggable node cards inside an SVG/canvas layer, styled with existing design tokens. Bind to the graph store for node lists and connections, showing typed input/output ports per node definition. Support gestures: drag to move, click toolbar to add node, drag from port to port to connect (validating fan-in/out rules), delete via keyboard. Provide accessible labels and integrate with undo/redo by calling store actions. Update `App.tsx` to mount the graph editor above the DevicePanel so authoring precedes bake/upload. Additionally, implement a dedicated DPR-aware canvas grid/edges layer leveraging `setupDprCanvas` and `resizeIfNeeded` from `studio/src/lib/canvas.ts` and an rAF loop patterned after `studio/src/features/timeline/TimelineCanvas.tsx`, including scroll-blit and dirty-region redraw similar to `maybeRebuildStatic`. Draw edges from graph store selectors (once the graph slice exists per Task 1) and clamp zoom to sane bounds. Add world pan/zoom transform, rubber-band selection, and hit-testing computed in transformed screen space with keyboard selection parity.\nWireframe refs: Timeline Editor screen in 'User-Facing App Wireframes 3/src/components/prism/TimelineEditorScreen.tsx' and App.tsx:Timeline; docs in PRODUCTION_READY_SUMMARY.md and WIRED_FUNCTIONALITY.md (Timeline zoom/scrub).\n\nAcceptance Checklist (wireframe parity)\n- [ ] Timeline zoom matches wireframe states (in/out extremes)\n- [ ] Scrubbing behavior & playhead visuals match wireframe\n- [ ] Keyboard focus order/tab stops per wireframe; ports tabbable\n- [ ] Canvas edges redraw correctly after pan/zoom (100 nodes/200 edges)",
        "testStrategy": "Use @testing-library/react and Vitest to simulate adding nodes, wiring them, and verifying DOM reflects store state; add Cypress/Playwright smoke test ensuring nodes persist after reload via project autosave. Extend with a performance harness asserting average draw/frame time ≤16.7ms while panning at ~100 nodes/200 edges, and accessibility tests validating focus management, tabbable ports, and Enter/Space activation (reuse Playwright config at `studio/playwright.config.ts`).\nVisual parity: zoom states and scrubbing match wireframe; keyboard focus order mirrors wireframe interactions.",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold GraphCanvas and node card layout",
            "description": "Create the GraphCanvas surface and supporting node card components within the graph feature.",
            "dependencies": [],
            "details": "Add GraphCanvas.tsx and child components that render nodes inside an SVG/canvas layer using existing design tokens and pull node data from the graph store.",
            "status": "pending",
            "testStrategy": "Render GraphCanvas with mocked store data in @testing-library/react and assert nodes and ports appear with correct styling.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement node gestures and connection wiring",
            "description": "Enable core authoring gestures for moving nodes, adding new nodes, and wiring ports with validation.",
            "dependencies": [
              1
            ],
            "details": "Wire drag handlers for node repositioning, toolbar actions for adding nodes, and port-to-port drag interactions that enforce fan-in/out rules and update the graph store.",
            "status": "pending",
            "testStrategy": "Use @testing-library/react with pointer events to simulate drag and connect flows, verifying store actions fire and DOM updates accordingly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate accessibility, undo/redo, and App mounting",
            "description": "Finalize editor integration with accessibility affordances and application shell embedding.",
            "dependencies": [
              1,
              2
            ],
            "details": "Provide ARIA labels, keyboard delete handling, undo/redo hookups via store actions, and mount the editor in App.tsx above the DevicePanel per layout requirements.",
            "status": "pending",
            "testStrategy": "Add React tests for keyboard delete and ARIA attributes, plus integration smoke test ensuring editor renders in App and undo/redo calls trigger store mocks.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Canvas grid/edges layer with DPR + dirty-region redraw",
            "description": "Add a DPR-aware canvas-backed grid/edges layer to GraphCanvas with scroll-blit and partial redraw.",
            "dependencies": [
              1
            ],
            "details": "Create a dedicated 2D canvas inside GraphCanvas using `setupDprCanvas` and `resizeIfNeeded` from `studio/src/lib/canvas.ts`. Drive rendering via an rAF loop following `studio/src/features/timeline/TimelineCanvas.tsx` (see `useRaf`, offscreen buffer, and `maybeRebuildStatic`-style scroll-blit). Render: (1) static grid lines to an offscreen buffer, (2) edges from graph selectors (e.g., `useGraphStore`-derived connections) onto the onscreen layer. On pan: blit the buffer and redraw only newly exposed strips; on zoom: rebuild the buffer. Clamp zoom to configured min/max to avoid numerical drift. Ensure edges reproject correctly under the world transform.",
            "status": "pending",
            "testStrategy": "- Vitest unit/perf harness: simulate 100 nodes/200 edges and programmatic pan; assert average rAF frame ≤16.7ms (60 FPS) over a 2s window using `performance.now()` sampling.\n- Visual correctness: after pan/zoom, edges connect the correct ports (no misalignment) by sampling projected endpoints from the store and comparing to canvas-drawn positions within ±1px.\n- Acceptance: Sustains ~60 FPS during continuous pan on dev hardware; edges remain correct after pan/zoom.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add pan/zoom + selection rectangle + hit-testing at scale",
            "description": "Implement world transform (pan/zoom), rubber-band selection, and accurate hit-testing under transforms.",
            "dependencies": [
              1,
              4
            ],
            "details": "Track `panX/panY/zoom` as a world transform applied to canvas draw and DOM overlay. Implement wheel zoom with clamped bounds and pointer-drag panning similar to TimelineCanvas interactions. Add a rubber-band selection rectangle overlay (DOM/SVG) that maps screen→world using the inverse transform. Compute hit-tests for nodes/ports using transformed bounds (Path2D or AABB in world space) and ensure keyboard selection (arrow keys, Shift+click/Space/Enter) mirrors pointer semantics.",
            "status": "pending",
            "testStrategy": "- @testing-library/react: simulate wheel zoom, pan drag, and Shift+drag rubber-band; verify selected node set matches expected world-space intersection at various zoom levels (min/max) with no drift beyond 1px tolerance.\n- Keyboard parity: simulate keyboard navigation/selection; assert selection result equals pointer-based selection for identical geometries.\n- Acceptance: Keyboard and pointer selection parity; rubber-band selects expected nodes; no hit-test drift at zoom extremes.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Performance and accessibility tests (60 FPS & WCAG)",
            "description": "Add automated performance and a11y coverage for the graph editor.",
            "dependencies": [
              2,
              4
            ],
            "details": "Introduce a perf harness that measures draw time while panning at scale (≈100 nodes/200 edges), validating average frame time ≤16.7ms. Add React Testing Library specs for focus order, roving tabindex (if used), and keyboard activation of ports/nodes (Enter/Space). Ensure ARIA roles/labels on the canvas/editor (patterned after `TimelineCanvas` role/label) and tabbable interactive ports.",
            "status": "pending",
            "testStrategy": "- Perf: rAF-based measurement test that drives pan over a synthetic graph and asserts average frame ≤16.7ms.\n- A11y: RTL tests confirm focus is trapped within the graph when active, ports/nodes are tabbable, and Enter/Space activate expected actions (selection/connection start/confirm). Optionally run Playwright to verify end-to-end tab order.\n- Acceptance: Perf harness passes; a11y tests pass with tabbable ports and Enter/Space activation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Create `studio/src/features/graph/GraphCanvas.tsx` with SVG/canvas layers and node card components bound to `useGraphStore` for nodes/edges. Implement interactions: drag to reposition (UI slice only), toolbar to add nodes, port‑to‑port drag to connect with `canConnect`/validation, keyboard delete. Add ARIA labels and focus management, and wire undo/redo via graph store. Mount the editor in `studio/src/App.tsx` above `DevicePanel`. Add @testing‑library/react tests for adding/moving/connecting/deleting nodes and ensuring DOM ↔ store sync; include a simple mocked store state provider for tests.",
        "updatedAt": "2025-10-17T10:17:15.700Z"
      },
      {
        "id": "3",
        "title": "Implement Graph Evaluation Engine",
        "description": "Evaluate authored node graphs into frame buffers at 60–120 FPS on the host, with an operator registry and compile cache supporting deterministic evaluation.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "Implement `studio/src/lib/graph/evaluator.ts` to compile node graphs into pure evaluator functions and stream frames. Align with existing project structure under `studio/src`. Core requirements:\n- Operators: Deterministic Noise2D (seeded), Gradient, Solid generators; affine transforms (Rotate, Scale, Mirror); combiners (Add, Multiply with clamping); color operators (PaletteMap placeholder, HueShift, Brightness).\n- Topology: Build execution order via topological sort; guard cycles and missing inputs; enforce FPS 60–120.\n- Registry + Compile Cache: Introduce `NodeDef`/`OpDef` types and a typed op registry (e.g., `studio/src/lib/graph/ops/registry.ts`) with parameter specs and ranges. Implement `compile(node)` returning a resolver; add a compile cache keyed by node id + params hash; clamp param inputs to declared ranges.\n- Seeding + Time Base: Define a stable, reproducible seed (from graph/project or node param) and use it to seed Noise2D. Provide deterministic time base `t` in seconds per frame (e.g., `frameIndex / fps`) passed to evaluators to ensure reproducibility across runs.\n- API: `evaluateGraph({ graph, seconds, fps, geometry })` returns/streams `Float32Array` RGB frames sized to 2×160 LEDs (320 px × 3 channels) and exposes hooks for per-frame consumption.\n- Errors: Clear errors for cycles, missing inputs, bad params (out of range), and invalid fps.\nSuggested file organization (adapt if needed):\n- `studio/src/lib/graph/evaluator.ts` – orchestration + topological sort + evaluateGraph\n- `studio/src/lib/graph/ops/*` – op implementations (`noise2d.ts`, `gradient.ts`, `solid.ts`, `affine.ts`, `combine.ts`, `color.ts`) and `registry.ts`\n- `studio/src/lib/graph/types.ts` – `Graph`, `Node`, `Port`, `OpDef`, `NodeDef`, and param range types.\nPerformance: Ensure p95 per-frame evaluation for 320 LEDs at 120 FPS is <5ms on dev hardware by minimizing allocations and leveraging compile cache.",
        "testStrategy": "Add Vitest suites under `studio/src/lib/graph/__tests__`:\n- Topology & Validation: cycle detection, missing inputs, fps bounds (60–120), topological order correctness using sample graphs.\n- Registry & Clamping: param range clamping tests and compile cache hit/miss behavior using a node+params hash key.\n- Determinism: seeded Noise2D produces reproducible buffers given the same seed and `t = frameIndex/fps` time base; changing seed or time changes output.\n- Math correctness: HueShift/Brightness arithmetic, affine transforms (Rotate/Scale/Mirror), combiners with clamping.\n- Integration & Frames: `evaluateGraph` yields correct frame count (`seconds × fps`) and buffer size (`320 * 3` floats) for sample graphs.\n- Performance: benchmark harness verifying p95 per-frame eval for 320 LEDs at 120 FPS is <5ms (skip in CI if necessary).",
        "subtasks": [
          {
            "id": 1,
            "title": "Design evaluator topology and validation layer",
            "description": "Establish evaluator scaffolding with data structures for graph nodes, edges, and execution order validation.",
            "dependencies": [],
            "details": "Create `studio/src/lib/graph/evaluator.ts` scaffolding with TypeScript types for nodes/ports, implement guards for missing inputs, enforce fps bounds, and add pure helpers for topological sorting plus cycle detection.",
            "status": "done",
            "testStrategy": "Author Vitest unit tests covering cycle detection, missing input errors, and fps range validation.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:34:01.393Z"
          },
          {
            "id": 2,
            "title": "Implement deterministic node resolver functions",
            "description": "Add resolver implementations for generators, transforms, combiners, and color operators with deterministic behavior.",
            "dependencies": [
              1
            ],
            "details": "Implement pure resolver factories for Noise2D using seeded simplex-noise, Gradient, Solid generators, affine transforms (Rotate, Scale, Mirror), combiners (Add, Multiply with clamping), and color operations (PaletteMap placeholder, HueShift, Brightness) producing Float32Array outputs.",
            "status": "done",
            "testStrategy": "Add Vitest cases verifying deterministic noise given a seed, correct transform math, and clamped combiner outputs.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:00.116Z"
          },
          {
            "id": 3,
            "title": "Stream evaluated frames via evaluateGraph API",
            "description": "Compose the full evaluation pipeline that builds execution order, executes resolvers per frame, and streams RGB buffers.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement `evaluateGraph({ graph, seconds, fps, geometry })` to topologically order resolvers, evaluate frames for 2×160 LEDs, accumulate Float32Array RGB outputs, and handle frame streaming hooks while propagating errors from invalid graphs.",
            "status": "done",
            "testStrategy": "Write Vitest suites ensuring frame counts equal seconds×fps, RGB buffer sizing is correct, and integration across sample graphs succeeds.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:01.014Z"
          },
          {
            "id": 4,
            "title": "Define op registry + compile cache + parameter ranges",
            "description": "Add typed operator registry with parameter specs, compile() per node, and a compile cache with clamped params.",
            "dependencies": [
              1
            ],
            "details": "Create `NodeDef`/`OpDef` types and parameter range definitions (e.g., min/max/step, enums). Implement a registry module (e.g., `studio/src/lib/graph/ops/registry.ts`) mapping op keys to `OpDef` with typed params and defaults. Provide `compile(node, registry)` that returns a pure evaluator and clamps incoming params to declared ranges. Add a compile cache keyed by stable node id + params hash to avoid rebuilding evaluators across frames.",
            "status": "done",
            "testStrategy": "Acceptance: (1) registry is exported with expected ops, (2) clamping applies to out-of-range params, (3) compile cache yields hits for identical node+params hash and misses when params change.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:01.940Z"
          },
          {
            "id": 5,
            "title": "Noise2D seeding and deterministic time base",
            "description": "Integrate stable seeding and a deterministic time base for Noise2D and time-dependent ops.",
            "dependencies": [
              2
            ],
            "details": "Derive a stable seed (e.g., from project/graph seed or explicit node param) and pass it to seeded Noise2D. Define a deterministic time base `t = frameIndex / fps` provided to evaluators so repeated runs with the same graph, seed, and fps produce identical outputs.",
            "status": "done",
            "testStrategy": "Acceptance: Reproducible output given the same seed and time `t`; different seed or time produces different outputs.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:02.762Z"
          },
          {
            "id": 6,
            "title": "Test vectors and performance benchmark (<5 ms)",
            "description": "Provide golden test vectors and a perf harness ensuring p95 < 5ms per frame for 320 LEDs @120 FPS.",
            "dependencies": [
              2,
              4
            ],
            "details": "Author Vitest cases for Solid, Gradient, Brightness, Rotate, and Noise2D operators producing small golden outputs. Add a performance benchmark that evaluates a representative graph at 320 LEDs × 120 FPS and asserts p95 eval time < 5ms on dev hardware. Use compile cache to minimize per-frame overhead.",
            "status": "done",
            "testStrategy": "Acceptance: Unit tests pass for the listed operators. Benchmark harness asserts p95 < 5 ms on dev hardware (allow skip in CI if variance is high).",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:28:54.145Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Add `studio/src/lib/graph/evaluator.ts` implementing: (1) topology builder with cycle detection and validation (missing inputs, fps bounds 60–120); (2) resolver factories for `Noise2D` (deterministic seeded noise), `Gradient`, `Solid`, affine transforms (`Rotate`,`Scale`,`Mirror`), combiners (`Add`,`Multiply` with clamping), and color ops (`PaletteMap` placeholder, `HueShift`,`Brightness`) producing `Float32Array`; (3) `evaluateGraph({ graph, seconds, fps, geometry })` that compiles resolvers in topological order and yields per‑frame RGB buffers for 2×160 LEDs; (4) Vitest covering topo sort, deterministic noise, math correctness, and frame count = seconds×fps.",
        "updatedAt": "2025-10-17T10:28:54.145Z"
      },
      {
        "id": "4",
        "title": "Add OKLCH Palette LUT Generation",
        "description": "Bake 256×RGB OKLCH lookup tables on the host per PRD color requirements, adding gamut handling modes, gamma policy coordination, and a memoized LUT cache with perf benchmarks.",
        "status": "done",
        "dependencies": [
          "1",
          "3"
        ],
        "priority": "high",
        "details": "- Add culori@^4 to `studio/package.json` and implement `studio/src/lib/color/oklchLut.ts` (new) to: (1) convert project palettes (see `studio/src/lib/projectSchema.ts` Palette) to OKLCH, (2) interpolate to 256 entries, (3) apply sRGB encoding per policy, and (4) return LUT bytes (Uint8Array RGB ×256) plus metadata.\n- API shape (typescript): `generateOklchLut(palette: string[], options?: { steps?: number; gamma?: number; gammaPolicy?: 'baked_2_2'|'flat_1_0'; gamutMode?: 'clip'|'compress'|'preserve-hue'; onStats?: (s:{fromCache:boolean; genMs:number})=>void }): { bytes: Uint8Array; meta: { steps:number; gamutMode:string; gammaPolicy:string; paletteHash:string } }`.\n- Gamut strategies in helper: `clip` (truncate out-of-gamut), `compress` (reduce chroma to fit, preserve L/H), and `preserve-hue` (hue-preserving compression along constant-H lines). Validate using synthetic high-L/high-C palettes.\n- Gamma policy coordination: default bake sRGB ≈2.2 into LUT bytes with device gamma set to 1.0; provide alternative policy `flat_1_0` (no bake) so device gamma applies, to avoid double-encoding. Expose via `gammaPolicy` option and thread through node integration (PaletteMap/HueShift/Brightness) in subtask 3.\n- Add an in-module memoized cache keyed by `paletteHash` + relevant options (steps, gammaPolicy, gamutMode). Expose lightweight stats via `onStats` callback and/or simple getter; log with `studio/src/lib/logger.ts` where appropriate.\n- File placement and conventions align with current project structure: TypeScript modules under `studio/src/lib`, vitest tests beside modules (e.g., `oklchLut.test.ts`), leveraging setup in `studio/src/test/setup.ts`. Node integration leverages forthcoming color nodes and respects existing UI flows in `studio/src/features/devices/DevicePanel.tsx` (for gamma controls in later tasks).",
        "testStrategy": "- Utility tests in `studio/src/lib/color/oklchLut.test.ts` validate: (1) output length 256, (2) endpoints match input palette bounds (within rounding), (3) gamma mapping correctness for `baked_2_2` vs `flat_1_0`, and (4) metadata fields populated.\n- Node integration tests (once nodes consume the helper) extend existing suites to ensure PaletteMap uses LUT indices correctly and the final RGB buffer matches expectations for both gamma policies.\n- Gamut strategy tests with synthetic palettes assert: no NaNs, out-of-gamut handling per mode, and hue preservation within tolerance (e.g., Δh ≤ 1–2° for preserve-hue).\n- Cache/perf tests: measure first-call vs cached-call timings and assert a perf guard on dev HW (<2 ms for cached path; relaxed threshold under `process.env.CI`). Verify cache hit rates are observable via stats hook.\n- Documentation check: verify gamma policy section added to `docs/user-manual.md` or a new `docs/bench/oklch.md` notes CI thresholds and measurement method.",
        "subtasks": [
          {
            "id": 1,
            "title": "Install culori and scaffold OKLCH LUT module",
            "description": "Add the culori package and create the initial OKLCH LUT helper file.",
            "dependencies": [],
            "details": "Add `culori@^4` to `studio/package.json`, install deps, and create `studio/src/lib/color/oklchLut.ts` with exported placeholders for LUT generation, metadata typing, and options (`gammaPolicy`, `gamutMode`, `steps`, `onStats`).",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:59.751Z"
          },
          {
            "id": 2,
            "title": "Implement OKLCH LUT generation pipeline",
            "description": "Fill the helper with full conversion, interpolation, and gamma logic.",
            "dependencies": [
              1
            ],
            "details": "Implement in `studio/src/lib/color/oklchLut.ts`: parse hex palette → OKLCH via culori, interpolate to 256 entries, apply sRGB encoding per `gammaPolicy` (`baked_2_2` default), and emit `{ bytes, meta }` including `paletteHash`, `steps`, `gamutMode`, `gammaPolicy`.",
            "status": "done",
            "testStrategy": "Vitest cases ensure 256-length output, endpoint fidelity (within 8-bit rounding), and gamma mapping correctness for both `baked_2_2` and `flat_1_0` policies.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:34:00.571Z"
          },
          {
            "id": 3,
            "title": "Integrate LUT helper into color nodes and tests",
            "description": "Update color nodes to consume the new LUT helper and validate behavior.",
            "dependencies": [
              2
            ],
            "details": "Refactor PaletteMap, HueShift, and Brightness evaluators to call the helper and pass through options (`gammaPolicy`, `gamutMode`). Evaluator should emit indexed palette references and final RGB buffer for packaging without changing external APIs.",
            "status": "done",
            "testStrategy": "Expand vitest suites for updated nodes to confirm LUT indices are applied, final RGB buffers align with expectations, and node-level gamma policy is honored without double-encoding.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:03.579Z"
          },
          {
            "id": 4,
            "title": "Implement gamut handling strategies and tests",
            "description": "Add clip/compress/preserve-hue gamut modes to the LUT helper and validate behavior.",
            "dependencies": [
              2
            ],
            "details": "Extend `studio/src/lib/color/oklchLut.ts` options with `gamutMode: 'clip'|'compress'|'preserve-hue'`. Implement: clip (truncate to sRGB), compress (reduce chroma to fit while preserving L/H as much as possible), preserve-hue (hue-preserving compression along constant-H lines). Validate using synthetic stress palettes (high C, high L).",
            "status": "done",
            "testStrategy": "Acceptance: (1) Unit tests produce no NaNs or Infs, (2) hue preserved within tolerance (e.g., Δh ≤ 2°) for preserve-hue, (3) out-of-gamut entries are handled per selected mode. Include tests in `studio/src/lib/color/oklchLut.gamut.test.ts`.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:04.399Z"
          },
          {
            "id": 5,
            "title": "Define gamma policy and device coordination",
            "description": "Decide and document gamma policy; plumb configuration through nodes to avoid double-encoding.",
            "dependencies": [
              3
            ],
            "details": "Adopt default policy: bake sRGB ≈2.2 into LUT bytes (`gammaPolicy='baked_2_2'`) and set device gamma to 1.0. Document alternative `flat_1_0` (no bake, device gamma applies). Add a config flag in the LUT options and ensure node integrations from subtask 3 forward the chosen policy. Document policy and trade-offs in `docs/user-manual.md` (Color/Gamma) including examples and when to use each.",
            "status": "done",
            "testStrategy": "Acceptance: (1) Config toggles switch the gamma pipeline in tests, (2) node integration honors the policy (no double-encoding), (3) documentation updated and linked in code comments (file paths referenced). Add verification tests in `oklchLut.test.ts` and node tests.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:28:55.009Z"
          },
          {
            "id": 6,
            "title": "Add paletteHash cache and LUT performance benchmarks",
            "description": "Memoize LUT results and add perf guard; expose stats for observability.",
            "dependencies": [
              2
            ],
            "details": "Implement a memoized cache in `oklchLut.ts` keyed by `paletteHash` + critical options (`steps`,`gammaPolicy`,`gamutMode`). Provide `onStats` callback for cache hit/miss and generation timing; optionally a simple `getCacheStats()` for tests. Add vitest perf tests that assert cached path completes under 2 ms on dev hardware and document relaxed CI thresholds in `docs/bench/oklch.md`.",
            "status": "done",
            "testStrategy": "Acceptance: (1) Cache hit rates measurable via stats hook, (2) perf tests pass on dev HW (<2 ms cached path; relax under `process.env.CI`), (3) CI thresholds and methodology documented with links to test files.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:05.214Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Install `culori@^4` and create `studio/src/lib/color/oklchLut.ts` exposing functions to: convert input palettes to OKLCH, interpolate to 256 entries, gamma‑map to 8‑bit sRGB (2.2), and return LUT bytes + metadata. Update color evaluators (`PaletteMap`,`HueShift`,`Brightness`) to consume the LUT helper and output both indexed references and final RGB buffers as needed. Add Vitest ensuring LUT length 256, edge color fidelity, gamma correctness, and PaletteMap index usage.",
        "updatedAt": "2025-10-17T10:28:55.009Z"
      },
      {
        "id": "5",
        "title": "Port ADR-009 .prism Packaging to TypeScript",
        "description": "Package evaluated frames into ADR-009 compliant .prism binaries with CRC-32.",
        "status": "done",
        "dependencies": [
          "3",
          "4"
        ],
        "priority": "high",
        "details": "Align implementation with current Studio/Tools layout. Build new TypeScript packer at `studio/src/lib/bake/packPrism.ts` and model its CRC usage on existing precedent in `studio/scripts/upload-pattern.mjs` (imports `crc-32`). Implement ADR-009 header assembly, payload chunking, XOR delta + RLE, palette metadata embedding, 256 KB cap enforcement, and CRC-32 IEEE 0xEDB88320 via the `crc-32` npm module already used in the repo. Provide API: `packPrism({ frames, fps, ledCount, paletteLut }) => { bytes: Uint8Array, stats: { version, frameCount, fps, ledCount, payloadSize, totalSize, headerCrc, payloadCrc, errors?: string[] } }`. Integrate stats with the project save flow in `studio/src/stores/project.ts` so the latest bake diagnostics are persisted for UI diagnostics. For Python parity and CRC cross-checks, use `tools/validation/prism_sanity.py` as the authoritative CRC verifier and create mirrored fixtures in `tools/tests/prism/` to compare bytes and CRCs. Tests should live under `studio/src/lib/bake/__tests__/packPrism.test.ts` and use `vitest` per `studio/vitest.config.ts`. Document size/CRC thresholds and error taxonomy to surface actionable messages to the UI and CI logs.",
        "testStrategy": "- Unit: Create Vitest cases under `studio/src/lib/bake/__tests__/packPrism.test.ts` comparing `packPrism` output to Python-generated fixtures in `tools/tests/prism/`. Assert byte-for-byte equality, header fields (version, frame count, fps), and both header/payload CRCs match values recomputed in test using `crc-32`.\n- Limits/guardrails: Tests for payload and total size boundaries (≤256 KB), invalid frames/palette lengths, and error taxonomy mapping (e.g., PRISM_TOO_LARGE, MALFORMED_FRAMES, PALETTE_LENGTH_MISMATCH) to actionable messages.\n- Integration: Stub the consumer in `studio/src/stores/project.ts` to confirm stats persistence and serialization/deserialization roundtrips. Ensure CI logs capture pack stats (sizes, CRCs) via a packer step and that UI components can read/display stats.\n- Parity: Add a script to re-verify fixtures with `tools/validation/prism_sanity.py` in CI; tests should fail if recomputed CRC mismatches.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design TypeScript packPrism module structure",
            "description": "Review ADR-009 and the Python packer to outline the new TypeScript API surface.",
            "dependencies": [],
            "details": "Audit current repo CRC usage in `studio/scripts/upload-pattern.mjs` and any ADR-009 rules, then define TypeScript typings for frames, stats, and packPrism parameters/return values. Document module responsibilities and expected locations: implementation in `studio/src/lib/bake/packPrism.ts`, tests in `studio/src/lib/bake/__tests__/packPrism.test.ts`.",
            "status": "done",
            "testStrategy": "Draft interface unit tests verifying TypeScript typings compile with example inputs and that `crc-32` import pattern matches `studio/scripts/upload-pattern.mjs`.",
            "updatedAt": "2025-10-17T08:33:49.041Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement ADR-009 binary assembly in TypeScript",
            "description": "Port the Python packaging logic into packPrism.ts covering headers, payload transforms, and CRC.",
            "dependencies": [
              1
            ],
            "details": "Translate header construction, frame chunking, XOR delta plus RLE compression, palette metadata embedding, and 256KB enforcement. Integrate `crc-32` to emit bytes and stats from `packPrism`. Place implementation in `studio/src/lib/bake/packPrism.ts` and export `packPrism` with the defined API.",
            "status": "done",
            "testStrategy": "Add Vitest cases comparing generated bytes/CRC against Python fixture outputs and asserting size guardrails. Use `crc-32` to recompute CRCs and confirm equality.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:49.867Z"
          },
          {
            "id": 3,
            "title": "Expose packPrism stats and persistence integration",
            "description": "Add UI-facing stats reporting and persist latest bake metrics in project save flow.",
            "dependencies": [
              1,
              2
            ],
            "details": "Extend `packPrism` return shape with error/size stats. Update `studio/src/stores/project.ts` save logic to store recent bake diagnostics (sizes, CRCs, counts). Ensure consumers (UI) handle the new data contract and display stats.",
            "status": "done",
            "testStrategy": "Write integration tests stubbing the packPrism consumer to confirm stats persistence in project state and regression tests for new metadata serialization.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:14:49.256Z"
          },
          {
            "id": 4,
            "title": "Add Python parity fixtures and CRC cross-checks",
            "description": "Parity fixtures & CRC verification.",
            "dependencies": [
              2
            ],
            "details": "Create Python-mirrored fixtures derived from an equivalent algorithm and verified by `tools/validation/prism_sanity.py`. Store under `tools/tests/prism/` (e.g., `.prism` binaries plus JSON of expected header/payload CRCs). In Vitest (`studio/src/lib/bake/__tests__/packPrism.test.ts`), assert byte-for-byte equality and both header/payload CRCs via `crc-32` recomputation.",
            "status": "done",
            "testStrategy": "- Fixture tests pass locally and in CI.\n- Recompute CRC in tests and compare to both packed output and stored expected values.\n- Fail tests if any mismatch is detected.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:50.677Z"
          },
          {
            "id": 5,
            "title": "Implement size/format guardrails and error mapping",
            "description": "Error taxonomy & guardrails.",
            "dependencies": [
              2
            ],
            "details": "Enforce ≤256KB cap and surface `PRISM_TOO_LARGE`. Validate frames and palette lengths; surface `MALFORMED_FRAMES`, `PALETTE_LENGTH_MISMATCH`, `UNSUPPORTED_FPS_BOUNDS` (if applicable). Map pack errors to user-facing guidance for Task 9 and include remediation tips in error strings. Ensure guardrails are applied before packaging to avoid wasted work.",
            "status": "done",
            "testStrategy": "- Add tests for oversize payloads, malformed inputs (empty frames, inconsistent frame sizes), invalid palette sizes.\n- Verify correct error codes/messages, and that `stats.errors` are populated.\n- Ensure process aborts early for fatal guardrail violations.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:14:50.097Z"
          },
          {
            "id": 6,
            "title": "CI packer step and stats reporting",
            "description": "CI integration & stats.",
            "dependencies": [
              3
            ],
            "details": "Add a CI step to run the packer against sample inputs and emit pack stats (sizes, CRCs) to logs. Expose a small API/read helper for UI to display pack stats and thresholds. Document thresholds (≤256KB total, CRC expectations) in `docs/` and ensure logs include the same metrics for quick diagnosis.",
            "status": "done",
            "testStrategy": "- CI logs contain pack stats for sample runs and fail on threshold violations.\n- UI reads and displays pack size/CRC from persisted stats.\n- Documentation updated with thresholds and how to interpret stats.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:06.029Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Create `studio/src/lib/bake/packPrism.ts` that assembles ADR‑009 headers, performs XOR‑delta + RLE compression, enforces ≤256 KB cap, embeds palette metadata, and computes CRC‑32 (use `crc-32`). Expose `packPrism({ frames, fps, ledCount, paletteLut }) => { bytes, stats }`. Add Vitest comparing bytes/CRC and header fields against known fixtures (add small golden fixtures under `tools/tests` or generate via Python reference if available). Extend save logic to persist recent bake stats for diagnostics.",
        "updatedAt": "2025-10-17T10:25:06.029Z"
      },
      {
        "id": "6",
        "title": "Implement Streaming Upload Backend",
        "description": "Add Tauri commands to stream .prism payloads over a single WebSocket with PUT_* frames, now including cancel/reconnect handling and 10Hz EMA throughput reporting.",
        "status": "done",
        "dependencies": [
          "5"
        ],
        "priority": "high",
        "details": "Extend or create `studio/src-tauri/src/lib.rs` with `#[tauri::command] async fn device_upload(host: String, meta: UploadMeta, pattern: Vec<u8>)`. Use TLV helpers (if not present, add a small module alongside `lib.rs`, e.g., `studio/src-tauri/src/tlv.rs`) to request STATUS for `maxChunk` before any socket work. Establish a persistent websocket session (e.g., via `tokio_tungstenite`) and send firmware-aligned TLV frames: `PUT_BEGIN` (pattern name, size, CRC-32), `PUT_DATA` in `maxChunk` slices, and `PUT_END` with CRC confirmation. Emit progress to the UI via `app.emit(\"upload:progress\", UploadProgress { bytesSent, total, throughputBps })`, throttled to 10Hz, where `throughputBps` is computed as an EMA over a short sliding window. Add cancel handling and single-attempt reconnection: on cancel, stop streaming, close WS, and emit `upload:cancelled`; on transient WS failure, retry once and re-run STATUS to refresh `maxChunk` prior to resuming, otherwise abort with a typed error. Enforce payload size ≤ 256 KB and return detailed errors mapped from firmware STATUS/ERROR TLVs. Use repo guidance in `docs/research/PRISM_Studio_Architecture_Research.md` for Tauri structure and security notes; place integration tests under `studio/src-tauri/tests/` and consider CRC alignment with existing CRC usage in Python utilities under `tools/validation/` (use Rust `crc32fast` for parity).\nWireframe refs: Device Sync progress/ack now reflected from wireframe docs (PRODUCTION_READY_SUMMARY.md WebSocket Device Sync; WIRED_FUNCTIONALITY.md Upload progress).\n\nAcceptance Checklist (wireframe parity)\n- [ ] STATUS.maxChunk probed before upload\n- [ ] PUT_BEGIN/PUT_DATA/PUT_END acknowledged (per firmware) or handled per policy\n- [ ] Progress events (percent/bytes/s/eta) emitted @<=10Hz\n- [ ] Cancel emits final 'upload:cancelled' and closes WS",
        "testStrategy": "- Unit tests (Rust):\n  - TLV framing helpers: verify correct TLV types and payload packing for PUT_BEGIN/PUT_DATA/PUT_END and STATUS.\n  - Size guard: reject payloads > 256 KB.\n  - Throughput EMA: deterministic sequence verifies EMA/window math and 10Hz throttle behavior.\n- Integration tests (Tokio + mocked tungstenite server) under `studio/src-tauri/tests/`:\n  - Happy path: PUT_BEGIN → PUT_DATA (exact and uneven chunking) → PUT_END; server acks and validates sequencing.\n  - CRC: server-induced CRC mismatch triggers mapped, descriptive error; success path confirms CRC.\n  - Progress: events delivered at ~10Hz, include non-negative `throughputBps`, and reach total bytes.\n  - Cancel: mid-stream cancel stops further frames and emits final `upload:cancelled` event.\n  - Reconnect: forced WS drop triggers one reconnect attempt with a re-STATUS; on second failure, upload aborts with a typed reconnect error.\n  - Timeout: server delay produces a specific timeout error code and message.\nBackend progress events render UI states as per wireframe progress examples.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define device_upload command skeleton",
            "description": "Add the async Tauri command stub with input validation and TLV setup.",
            "dependencies": [],
            "details": "Create `#[tauri::command] async fn device_upload(host: String, meta: UploadMeta, pattern: Vec<u8>)` in `studio/src-tauri/src/lib.rs`. Validate payload size ≤ 256 KB. Derive/calc CRC-32 (e.g., `crc32fast`) and call TLV STATUS to fetch `maxChunk` prior to socket work. Prepare `UploadProgress` struct matching emission payload.",
            "status": "done",
            "testStrategy": "Add a Rust unit test enforcing the size guard (>256 KB rejected). Add a unit test ensuring STATUS request is prepared before any websocket initiation.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:51.467Z"
          },
          {
            "id": 2,
            "title": "Stream PUT_* frames over persistent websocket",
            "description": "Implement the websocket session to stream pattern bytes using TLV PUT frames.",
            "dependencies": [
              1
            ],
            "details": "Open a persistent websocket to the target `host`. Send `PUT_BEGIN` with metadata (pattern name, total size, CRC-32). Iterate the pattern buffer in `maxChunk`-sized slices and send `PUT_DATA` per slice. After the final chunk, send `PUT_END` with CRC confirmation. Await and validate server acks and finalization before returning success.",
            "status": "done",
            "testStrategy": "Mock a tungstenite server to validate sequencing: `PUT_BEGIN` → `PUT_DATA` (correct chunk boundaries) → `PUT_END`. Assert that off-by-one and uneven sizes are chunked correctly and acknowledged in order.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:52.304Z"
          },
          {
            "id": 3,
            "title": "Emit progress and translate firmware errors",
            "description": "Report upload progress and map TLV errors to readable failures with tests.",
            "dependencies": [
              1,
              2
            ],
            "details": "During streaming, emit app events via `app.emit(\"upload:progress\", UploadProgress { bytesSent, total, throughputBps })`. Capture firmware STATUS/ERROR TLVs and map them to typed, descriptive errors (e.g., codes like `err.status.max_chunk_unsupported`, `err.crc.mismatch`, `err.ws.timeout`). Return a structured Result with these error categories.",
            "status": "done",
            "testStrategy": "Integration test asserts progress events fire with increasing `bytesSent` and include `throughputBps`. Inject ERROR TLVs in the mock server and assert mapped, descriptive error codes/messages are returned.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T09:35:48.215Z"
          },
          {
            "id": 4,
            "title": "Implement upload cancel and reconnection handling",
            "description": "Support cancellation and a single reconnection attempt with re-STATUS before aborting.",
            "dependencies": [
              2
            ],
            "details": "Add a cancel path that immediately stops streaming, cleanly closes the websocket, and marks the upload as cancelled; consistently emit `upload:cancelled`. Implement reconnection logic: on WS disconnect/connect error, retry connection once; re-run STATUS to refresh `maxChunk`; if reconnect fails again or STATUS differs incompatibly, abort with a typed reconnect error. Ensure in-progress state is preserved/restored correctly if resuming after reconnect.",
            "status": "done",
            "testStrategy": "Integration tests: (1) Cancel mid-stream → stop sending frames immediately and emit `upload:cancelled` once. (2) Simulate WS drop → exactly one reconnect attempt; verify a second failure returns a distinct reconnect error; verify a successful reconnect re-runs STATUS before resuming.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T09:05:11.993Z"
          },
          {
            "id": 5,
            "title": "Add progress EMA and throughput reporting",
            "description": "Report 10Hz-throttled progress events including EMA throughput.",
            "dependencies": [
              3
            ],
            "details": "Compute an EMA throughput (bytes/s) over a short sliding window (e.g., 1–3 s) using monotonically increasing time (Tokio Instant). Include `throughputBps` in progress events. Throttle `upload:progress` emissions to ~10Hz for consistent UI updates and lower overhead. Keep event shape consistent with the existing `UploadProgress` struct in `studio/src-tauri/src/lib.rs` (or a new `events.rs` if modularized).",
            "status": "done",
            "testStrategy": "- Unit tests for EMA: feed fixed byte/time samples → assert EMA matches expected within tolerance. - Integration: assert progress events are spaced at ~100 ms intervals and include `throughputBps ≥ 0`, converging appropriately under steady transfer.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T09:05:12.816Z"
          },
          {
            "id": 6,
            "title": "Add mock WS device and integration tests",
            "description": "Introduce a mock tungstenite server to validate TLV ACK/CRC behavior and error paths.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create a Tokio-based mock WS server helper under `studio/src-tauri/tests/` that: responds to STATUS with `maxChunk`, ACKs `PUT_BEGIN`/`PUT_DATA`/`PUT_END`, validates chunk sizes and total length, verifies CRC, and can inject errors/timeouts (e.g., mid-stream drops, invalid CRC, delayed ACK). Reuse any shared TLV type definitions to ensure parity with client framing.",
            "status": "done",
            "testStrategy": "Integration tests cover: (1) exact and uneven chunk boundaries, (2) CRC success and CRC mismatch mapping, (3) cancellation emits `upload:cancelled` and halts frames, (4) reconnect tries once and re-STATUS before resuming/aborting, (5) timeout surfaces a clear timeout error class.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:14:51.004Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "In `studio/src-tauri/src/lib.rs`, add `#[tauri::command] async fn device_upload(host: String, meta: UploadMeta, pattern: Vec<u8>)` that: validates ≤256 KB; queries STATUS for `maxChunk`; opens a persistent WebSocket; sends TLV `PUT_BEGIN` (name,size,crc), streams `PUT_DATA` in `maxChunk` slices, then `PUT_END`; emits `upload:progress` events with bytes/throughput; maps error TLVs to readable strings. Use existing `tlv_request` and tungstenite patterns as a reference and mirror framing constants from `scripts/upload-pattern.mjs`. Add Rust tests with a mocked tungstenite server for chunking and CRC validation.",
        "updatedAt": "2025-10-17T10:14:51.004Z"
      },
      {
        "id": "7",
        "title": "Integrate Bake & Upload Workflow in UI",
        "description": "Wire graph evaluation, packaging, and device upload into a cohesive \"Bake & Upload\" flow.",
        "details": "Add a primary button in `DevicePanel.tsx` (or new `BakePanel.tsx`) that triggers `async function bakeAndUpload()` calling evaluator (Task 3), LUT builder (Task 4), packPrism (Task 5), then invokes `device_upload` (Task 6). Show realtime progress via a new Zustand slice (`useUploadStore`) and render percent + throughput with cancel option. After successful upload, auto-call CONTROL PLAY (once Task 8 exists) and log timings to measure TTFL. Persist last bake stats in project metadata for debugging.\nWireframe refs: Progress panel states (active/cancelled/error), TTFL display, and retry per wireframes.\n\nAcceptance Checklist (wireframe parity)\n- [ ] ProgressPanel shows active/cancelled/error states\n- [ ] TTFL displayed after auto-PLAY\n- [ ] Retry available after error; resets store cleanly",
        "testStrategy": "Create React component tests stubbing Tauri to ensure progress UI updates and error states render; add Playwright E2E that bakes the seeded sample graph, uploads to a mocked backend, and verifies completion banner.\nUI progress/TTFL matches wireframe states across happy-path and error flows.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement upload progress Zustand slice",
            "description": "Create a dedicated `useUploadStore` slice to track bake/upload progress, errors, timing and cancellation state.",
            "dependencies": [],
            "details": "Define state fields for phase, percent complete, bytes per second, started/completed timestamps, and last error; expose actions to start/reset/cancel uploads, feed progress payloads, and register/unregister the Tauri `upload:*` listeners so UI stays in sync.",
            "status": "done",
            "testStrategy": "Add vitest store tests that fake progress and error events, assert throughput math, and confirm cancel/reset actions clear listeners.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:53.106Z"
          },
          {
            "id": 2,
            "title": "Build bakeAndUpload orchestration flow",
            "description": "Wire an `async bakeAndUpload` helper that sequences evaluator, LUT builder, packPrism, and device upload while updating the progress store.",
            "dependencies": [
              1
            ],
            "details": "Compose the graph evaluation, LUT generation, and packaging utilities, invoke `device_upload` with cancellation support, emit store updates at each stage, and record timing checkpoints for bake, pack, upload, and overall TTFL to feed metrics.",
            "status": "done",
            "testStrategy": "Write integration-like vitest covering happy path and failure branches by stubbing evaluator, packer, and upload functions to ensure store transitions and error propagation behave as expected.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:53.978Z"
          },
          {
            "id": 3,
            "title": "Integrate Bake & Upload UI controls",
            "description": "Add the primary Bake & Upload entry point in `DevicePanel` (or new `BakePanel`), render progress telemetry, and persist post-upload metadata.",
            "dependencies": [
              2
            ],
            "details": "Insert a primary button that invokes `bakeAndUpload`, render progress percent/throughput with cancel option bound to the store, trigger CONTROL PLAY on success when Task 8 is available, surface toast/logging, and save last run metrics into project metadata for debugging.",
            "status": "done",
            "testStrategy": "Create React Testing Library specs that mock the store to cover idle/loading/success states, verify cancel disables the flow, ensure CONTROL PLAY dispatch fires on completion, and confirm metadata persistence calls occur.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:54.837Z"
          },
          {
            "title": "Add ProgressPanel component and UI states",
            "description": "Create ProgressPanel.tsx rendering phase/percent/throughput/eta with cancel and retry; subscribe to upload:* events.",
            "dependencies": [
              2
            ],
            "details": "Mount in DevicePanel; show determinate/indeterminate; disable controls during upload; expose minimal props for reuse.",
            "status": "done",
            "testStrategy": "RTL tests for idle/active/cancelled/error states; snapshot basic rendering.",
            "id": 4,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:55.652Z"
          },
          {
            "title": "Implement error mapping util for Bake/Upload",
            "description": "Add mapUploadError() to convert backend codes to user guidance and toasts.",
            "dependencies": [
              2
            ],
            "details": "Map NET_*, DEV_*, INT_*, SIZE_*; ensure UI surfaces remediation hints.",
            "status": "done",
            "testStrategy": "Unit tests for mapping table and fallbacks.",
            "id": 5,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T09:35:45.902Z"
          },
          {
            "title": "Persist TTFL and last-bake stats",
            "description": "Save TTFL, sizes, crc to project metadata after success for diagnostics.",
            "dependencies": [
              2
            ],
            "details": "Extend project store save path to include last bake stats; render in UI.",
            "status": "done",
            "testStrategy": "Unit tests verifying persistence and read-back.",
            "id": 6,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:14:51.829Z"
          },
          {
            "title": "Playwright E2E for Bake→Upload happy path",
            "description": "End-to-end test (fake backend) that runs Bake→Upload and verifies UI progression.",
            "dependencies": [
              2,
              3
            ],
            "details": "Use mocked Tauri events; assert final success and TTFL shown.",
            "status": "done",
            "testStrategy": "Playwright spec with deterministic timings.",
            "id": 7,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:06.864Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Add `useUploadStore` (Zustand) to track phase, percent, throughput, timestamps, error, and cancellation. Implement `bakeAndUpload` orchestration that calls evaluator (Task 3), LUT (Task 4), and `packPrism` (Task 5), then invokes Tauri `device_upload` (Task 6), updating progress via store and handling cancel. Mount a primary “Bake & Upload” control in `DevicePanel.tsx` (or `BakePanel.tsx`) with progress UI and TTFL timings; after success, trigger CONTROL PLAY when Task 8 exists. Add component tests stubbing Tauri and asserting progress transitions.",
        "updatedAt": "2025-10-17T10:25:06.864Z"
      },
      {
        "id": "8",
        "title": "Implement Device Playback & Parameter Controls",
        "description": "Support PLAY/STOP and brightness/gamma adjustments per firmware CONTROL subcommands.",
        "details": "Extend Tauri with `device_control_play`, `device_control_stop`, and `device_control_params` that wrap TLV CONTROL messages (type 0x31) with subcommand bytes for play/stop/brightness/gamma as defined in firmware spec. Update `DevicePanel.tsx` to surface buttons/toggles and sliders (0–100% brightness, gamma 1.0–3.0) bound to these commands, reflecting status via websockets or follow-up STATUS calls. Log actions through `lib/logger.ts` and disable controls when no device selected or upload in-flight.\nWireframe refs: Transport controls and device controls per wireframe Devices and Timeline tabs.\n\nAcceptance Checklist (wireframe parity)\n- [ ] PLAY/STOP buttons and shortcuts (mod+P/S) work\n- [ ] Brightness/gamma sliders ramp with 100–150ms throttle\n- [ ] Values clamped and validated before CONTROL",
        "testStrategy": "Add Rust unit tests asserting CONTROL TLV payload layout. Write React tests confirming sliders call the correct Tauri invoke args and that UI disables appropriately when device not connected.\nControls/shortcuts verified against wireframe interactions (labels, focus, ramp semantics).",
        "priority": "medium",
        "dependencies": [
          "6",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement TLV control commands in Tauri",
            "description": "Add TLV wrappers for playback and parameter control commands in the Tauri backend.",
            "dependencies": [],
            "details": "Create device_control_play, device_control_stop, and device_control_params that wrap CONTROL type 0x31 messages with firmware-defined subcommand bytes and encode brightness and gamma payloads correctly.",
            "status": "done",
            "testStrategy": "Write Rust unit tests covering TLV payload layouts for play, stop, brightness, and gamma variants.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:56.469Z"
          },
          {
            "id": 2,
            "title": "Add playback and parameter UI controls",
            "description": "Expose playback toggles and parameter sliders in DevicePanel tied to new backend commands.",
            "dependencies": [
              1
            ],
            "details": "Update DevicePanel.tsx to render play/stop buttons and sliders for brightness 0–100% and gamma 1.0–3.0, binding each control to the new Tauri invokes and managing local state for current values.",
            "status": "done",
            "testStrategy": "Add React component tests asserting the correct invoke arguments fire when interacting with buttons and sliders and that controls disable when no device is selected.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:14:52.642Z"
          },
          {
            "id": 3,
            "title": "Integrate status feedback and logging",
            "description": "Handle control state feedback, logging, and disable conditions across the panel.",
            "dependencies": [
              1,
              2
            ],
            "details": "Wire websocket or STATUS polling responses to update control indicators, route user actions through lib/logger.ts, and enforce disabled states during uploads or when no device is active.",
            "status": "done",
            "testStrategy": "Extend component tests or utilities to verify status updates refresh UI, logging is triggered via mocks, and disable rules hold during simulated upload states.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:25:07.695Z"
          },
          {
            "title": "Keyboard shortcuts & a11y tests",
            "description": "Add WCAG-friendly shortcuts (Play/Stop, brightness/gamma adjust) and RTL tests for focus/aria.",
            "dependencies": [
              2
            ],
            "details": "Implement mod+P (play), mod+S (stop), Arrow keys for sliders with proper aria attributes.",
            "status": "done",
            "testStrategy": "RTL tests verify keyboard activation and aria roles.",
            "id": 4,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:14:53.470Z"
          },
          {
            "title": "Throttled ramp semantics & validation",
            "description": "Throttle brightness/gamma slider updates and validate ranges before CONTROL dispatch.",
            "dependencies": [
              2
            ],
            "details": "100–150ms throttle; clamp values; guard disabled state during uploads.",
            "status": "done",
            "testStrategy": "Unit tests for throttle and clamping; integration verifies fewer CONTROL sends.",
            "id": 5,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:14:54.310Z"
          },
          {
            "title": "Error mapper + toasts for CONTROL",
            "description": "Map CONTROL errors to friendly messages and surface as toasts/logs.",
            "dependencies": [
              2
            ],
            "details": "Reuse error util; ensure non-fatal STOP errors are informational.",
            "status": "pending",
            "testStrategy": "Unit tests for mapping; RTL checks toasts render.",
            "id": 6,
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Add Tauri commands `device_control_play`, `device_control_stop`, and `device_control_params` that wrap TLV CONTROL (0x31) per firmware subcommands, encoding brightness (0–100%) and gamma (1.0–3.0). Update `DevicePanel.tsx` to render play/stop and sliders bound to invokes, reflect state via STATUS polling or WS responses, and log via `lib/logger.ts`. Add Rust unit tests for CONTROL TLV payloads and React tests asserting correct invoke args and disabled states without a selected device.",
        "updatedAt": "2025-10-17T10:35:11.302Z"
      },
      {
        "id": "9",
        "title": "Surface Upload Progress, Errors, and TTFL Metrics",
        "description": "Deliver actionable progress UI, error mapping, and instrumentation to meet <3 min TTFL.",
        "details": "Augment `DevicePanel` and logger to subscribe to `upload:progress` / `upload:error` events, mapping error codes (CRC mismatch, TLV_CRC_INVALID, DEVICE_ERROR strings) to friendly messages with resolution tips. Record timeline marks (`performance.now()`) for graph bake, packaging, upload, and play commands, displaying latest TTFL and throughput in the UI. Add retry hints for oversized graphs (>256 KB) and highlight when fps defaults down from 120 due to limits.\nWireframe refs: Progress + error display patterns per WIRED_FUNCTIONALITY.md and PRODUCTION_READY_SUMMARY.md.\n\nAcceptance Checklist (wireframe parity)\n- [ ] Telemetry schema covers phases/percent/bytes/s/TTFL\n- [ ] Errors mapped to friendly messages per taxonomy\n- [ ] Optional JSONL export present in logs/",
        "testStrategy": "Add vitest tests for error mapper utility to ensure firmware errors map correctly. Use Playwright to simulate slow uploads (mock progress) validating TTFL metrics render and update. Verify logger receives structured entries.\nTelemetry/alerts presentation aligns with wireframe UI patterns.",
        "priority": "high",
        "dependencies": [
          "7",
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Instrument upload progress and TTFL timing hooks",
            "description": "Subscribe to upload events and capture timing metrics for bake, package, upload, and play.",
            "dependencies": [],
            "details": "Extend DevicePanel state management to listen for upload:progress and upload:error events, capture performance.now() marks for each upload phase, compute TTFL and throughput, and persist the latest metrics for display/logging.",
            "status": "done",
            "testStrategy": "Write unit tests that mock event emissions to ensure timing metrics and throughput calculations update as expected.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:57.285Z"
          },
          {
            "id": 2,
            "title": "Map firmware error codes to user-facing guidance",
            "description": "Create friendly messages and recovery tips for known upload error codes.",
            "dependencies": [],
            "details": "Implement an error mapping utility covering CRC mismatch, TLV_CRC_INVALID, DEVICE_ERROR variants, and oversized graph cases, providing user copy with resolution tips and retry guidance for >256 KB payloads.",
            "status": "done",
            "testStrategy": "Add vitest coverage verifying each error code yields the correct message, resolution hint, and logger payload.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T09:35:47.390Z"
          },
          {
            "id": 3,
            "title": "Render progress UI with TTFL, throughput, and fallback alerts",
            "description": "Display actionable progress, error, and performance signals in DevicePanel.",
            "dependencies": [
              1,
              2
            ],
            "details": "Update DevicePanel UI to render progress bars, TTFL and throughput metrics, show retry hints for large graphs, and highlight when FPS drops from 120, ensuring structured logs reflect the surfaced state.",
            "status": "done",
            "testStrategy": "Use React component tests to confirm progress UI reacts to mocked state changes and Playwright to validate end-to-end display of TTFL, throughput, and error hints.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:58.124Z"
          },
          {
            "title": "Telemetry types & mappers module",
            "description": "Create telemetry.ts with types for phases, progress payloads, and error taxonomy.",
            "dependencies": [],
            "details": "Exports UploadPhase, UploadProgress, UploadErrorCode and mapping helpers.",
            "status": "pending",
            "testStrategy": "Unit tests for schema and mapping.",
            "id": 4,
            "parentId": "undefined"
          },
          {
            "title": "Wire DevicePanel to telemetry events",
            "description": "Subscribe to telemetry:* and upload:* events; render TTFL/throughput; throttle updates.",
            "dependencies": [
              1
            ],
            "details": "Ensure UI updates at <=10Hz; combine with upload slice.",
            "status": "done",
            "testStrategy": "RTL tests for throttling and correct field rendering.",
            "id": 5,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T08:33:58.933Z"
          },
          {
            "title": "Dashboard hooks & JSONL export",
            "description": "Add optional JSONL log export for soak/CI and dashboard ingestion.",
            "dependencies": [],
            "details": "Append to logs/recent_uploads.jsonl with structured entries.",
            "status": "pending",
            "testStrategy": "Integration test writes JSONL and validates fields.",
            "id": 6,
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Subscribe UI to `upload:progress`/`upload:error` and compute TTFL by marking bake, pack, upload, and play timings using `performance.now()`. Implement an error mapping utility for firmware codes (CRC mismatch, TLV_CRC_INVALID, DEVICE_ERROR variants, oversized payload), reusing semantics from `scripts/upload-pattern.mjs`. Render progress bars, TTFL and throughput, and show retry hints for >256 KB payloads or FPS downshift. Add unit tests for error mapping and component tests simulating slow progress and verifying metrics/log output.",
        "updatedAt": "2025-10-17T10:35:12.142Z"
      },
      {
        "id": "10",
        "title": "Automate Reliability & Performance Validation",
        "description": "Create automated tests to prove 50 consecutive uploads succeed and 120 FPS holds.",
        "details": "Write a soak script in `tools/validation/soak_playlist.ts` (or extend existing `tools/validation/soak_playlist.py`) that drives the Bake & Upload flow via Tauri CLI hooks or Playwright, executing 50 uploads against a loopback device stub verifying CRC at PUT_END. Add vitest performance tests asserting evaluator maintains 120 FPS for 2×160 LEDs (<16.7ms/frame) and integrate metrics into CI. Document manual visual verification steps in `docs/validation/TTFL.md` for hardware-in-loop checks.",
        "testStrategy": "Run soak script in CI nightly with artifacts capturing throughput/TTFL, failing if any CRC mismatch or upload error occurs. Include vitest performance assertions and Playwright regression to confirm fps + TTFL thresholds.",
        "priority": "medium",
        "dependencies": [
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Build soak upload script for 50-run reliability",
            "description": "Implement an automated soak runner that executes 50 consecutive Bake & Upload cycles against a loopback stub via Tauri CLI or Playwright.",
            "dependencies": [],
            "details": "Create or extend tooling in `tools/validation/soak_playlist.(ts|py)` to orchestrate Bake & Upload workflows, drive the loopback device stub, verify CRC at PUT_END, gather timing metrics, and expose CLI flags for run count and report output.",
            "status": "done",
            "testStrategy": "Execute the soak script locally against the stub ensuring 50 uploads succeed without CRC mismatches, then add it to nightly CI and confirm artifacts capture upload metrics.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:34:44.021Z"
          },
          {
            "id": 2,
            "title": "Implement 120 FPS performance regression tests",
            "description": "Add automated performance checks ensuring evaluator sustains 120 FPS for 2×160 LEDs with <16.7 ms frame times.",
            "dependencies": [],
            "details": "Author vitest performance suites that load representative playlists, benchmark the evaluator for 2×160 LED payloads, assert frame processing stays under the 16.7 ms ceiling, and publish metrics for CI consumption alongside soak results.",
            "status": "done",
            "testStrategy": "Run the new vitest performance suite locally and in CI, failing the build when frame timing exceeds thresholds or metrics are missing.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:34:44.839Z"
          },
          {
            "id": 3,
            "title": "Document manual TTFL hardware verification protocol",
            "description": "Capture human-in-the-loop validation steps for verifying throughput and TTFL on real hardware.",
            "dependencies": [
              1,
              2
            ],
            "details": "Update `docs/validation/TTFL.md` detailing required test rigs, visual inspection checklist, confirmation steps for 50-upload soak results, FPS telemetry expectations, recovery actions, and how to correlate with automated soak/perf logs.",
            "status": "done",
            "testStrategy": "Have a teammate follow the documented procedure on hardware to ensure clarity and complete coverage, incorporating feedback into the document.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:34:45.691Z"
          },
          {
            "title": "Mock WebSocket device tool",
            "description": "Implement tools/validation/mock_device_ws.mjs handling TLV and CRC checks.",
            "dependencies": [],
            "details": "Ack PUT_*, enforce offsets, verify CRC on PUT_END; inject errors.",
            "status": "done",
            "testStrategy": "Self-test validating TLV/CRC paths.",
            "id": 4,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:34:46.528Z"
          },
          {
            "title": "CI artifacts & thresholds",
            "description": "Produce summary.json with TTFL/throughput; fail on thresholds; upload artifacts.",
            "dependencies": [
              1
            ],
            "details": "Integrate with CI; parametrize limits; attach logs and bundles.",
            "status": "pending",
            "testStrategy": "CI job dry run captures artifacts and enforces thresholds.",
            "id": 5,
            "parentId": "undefined"
          },
          {
            "title": "Repro bundle collection",
            "description": "On failure, collect inputs, transcript, env and write to artifacts.",
            "dependencies": [
              1
            ],
            "details": "Zip .prism, chunks, error logs; include device STATUS and env snapshot.",
            "status": "done",
            "testStrategy": "Unit/integration test creates a sample bundle on forced failure.",
            "id": 6,
            "parentId": "undefined",
            "updatedAt": "2025-10-17T10:34:47.405Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Create `tools/validation/soak_playlist.ts` (or extend the existing Python soak tooling) to drive 50 Bake & Upload cycles via Playwright or a Tauri CLI hook against a loopback device stub that verifies CRC at PUT_END. Add Vitest performance tests ensuring the evaluator sustains 120 FPS for 2×160 LEDs (<16.7 ms/frame) on representative graphs. Document hardware‑in‑loop TTFL checks in `docs/validation/TTFL.md` with steps, expected telemetry, and recovery actions; wire the soak/perf runs into CI with artifact capture.",
        "updatedAt": "2025-10-17T10:44:15.439Z"
      },
      {
        "id": "11",
        "title": "Integrate Wireframes with Task Plan",
        "description": "Map the new wireframe prototype to tasks, align acceptance criteria, and ensure component/interaction parity across Timeline, Device Manager, and Bake→Upload flows.",
        "details": "Source: User-Facing App Wireframes 3 (local code bundle) and Figma link in README. Produce a traceability matrix linking wireframe screens/components to tasks/subtasks, update acceptance criteria in tasks to reference wireframe states, and flag any gaps as follow-up tasks.",
        "priority": "medium",
        "status": "done",
        "dependencies": [],
        "testStrategy": "Traceability matrix present; reviewers can click from each task to the corresponding wireframe section. Acceptance criteria updated to reference specific screen states. All gaps are captured as subtasks or new tasks.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create traceability matrix",
            "description": "List wireframe screens/components and map to tasks/subtasks (2,3,6,7,8,9,10).",
            "dependencies": [],
            "details": "Include paths: User-Facing App Wireframes 3/src/App.tsx, components/prism/*. Reference Figma URL in README.",
            "status": "pending",
            "testStrategy": "Matrix reviewed and approved; links open relevant files/IDs.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update acceptance criteria with wireframe references",
            "description": "For tasks 2,6,7,8,9, update acceptance to cite wireframe screen states (Timeline, Devices, Progress).",
            "dependencies": [
              1
            ],
            "details": "Add references like “matches TimelineEditorScreen state A/B/C” and specific UI interactions.",
            "status": "pending",
            "testStrategy": "Spot-check tasks show explicit references to screens; QA can verify visually.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Component inventory and design tokens alignment",
            "description": "Inventory wireframe components (Radix UI set) and align with Studio components/tokens.",
            "dependencies": [
              1
            ],
            "details": "List Accordion/Dialog/Slider/Select/Progress; confirm usage and theming match existing tokens.",
            "status": "pending",
            "testStrategy": "Checklist done; any missing components are added as follow-up tasks.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Interaction parity checklist",
            "description": "Document keyboard shortcuts, drag behaviors, and progress states from wireframes and ensure they appear in tasks 2/7/8/9.",
            "dependencies": [
              1
            ],
            "details": "Capture Timeline scrubbing, zoom, device add/remove, progress cancel/retry, auto-play.",
            "status": "pending",
            "testStrategy": "Checklist linked in tasks; QA can validate against wireframe behavior.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-17T10:34:48.256Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-17T10:44:15.440Z",
      "taskCount": 11,
      "completedCount": 11,
      "tags": [
        "master"
      ]
    }
  }
}