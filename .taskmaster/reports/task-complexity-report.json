{
	"meta": {
		"generatedAt": "2025-10-17T11:08:30.479Z",
		"tasksAnalyzed": 3,
		"totalTasks": 14,
		"analysisCount": 3,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 12,
			"taskTitle": "Define Protocol Source of Truth and Pin SHAs",
			"complexityScore": 7,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Create docs/protocol/source-of-truth.md with sections TLV wire format, ADR-009 header, size limits, pinning policy, cross-repo references, owners; add pinned permalinks for firmware/components/network/include/protocol_parser.h, firmware/components/network/protocol_parser.c, firmware/components/core/include/prism_config.h, studio/src/lib/bake/packPrism.ts using current HEAD SHA; add backlink in firmware/README.md WebSocket Protocol and header comments in studio/scripts/upload-pattern.mjs and studio/src/lib/bake/packPrism.ts; implement tools/docs/pin_protocol_links.(ts|py) to read git rev-parse HEAD (or --sha) and regenerate a Markdown block of pinned links; add a CI script that parses pinned links and runs git cat-file -e <sha>:<path> and verifies PATTERN_MAX_SIZE (262144) parity via rg across firmware header and packPrism.ts; document rationale per artifact and anchors (#tlv-wire-format, #adr-009-header, #control-and-status).",
			"reasoning": "Greenfield doc plus a small generator and CI validation across firmware and Studio. Multiple touch points (docs, script, firmware README, Studio headers) and consistency checks increase coordination cost. No deep refactors, but careful link/pin handling and constant parity checks raise complexity above average."
		},
		{
			"taskId": 13,
			"taskTitle": "Confirm CONTROL TLV spec and align Studio + firmware",
			"complexityScore": 8,
			"recommendedSubtasks": 9,
			"expansionPrompt": "Update firmware header firmware/components/network/include/protocol_parser.h to document CONTROL type 0x20 and subcommands with byte-accurate payloads (PLAY 0x01, STOP 0x02, BRIGHTNESS 0x10: [cmd,u8,durBE], GAMMA 0x11: [cmd,u16BE,durBE]) and error code table; in firmware/components/network/protocol_parser.c add CONTROL_CMD_GAMMA macro and replace literal case 0x11, add bounds checks (brightness 0..255, gamma_x100 50..500) returning ERR_INVALID_FRAME on violation; keep big-endian parsing; confirm Studio Tauri builders in studio/src-tauri/src/lib.rs use type 0x20 and BE fields (they do), adjust labels/tooltips in studio/src/features/devices/DevicePanel.tsx to reflect 0–100% → 0..255 and 0.50–5.00 → 50..500; extend studio/src/lib/uploadErrors.ts to parse MSG_TYPE_ERROR (0xFF) payload code byte and map {0x05:\"Pattern not found\",0x04:\"Device storage full\",0x03:\"Pattern exceeds 256 KB\",0x02:\"CRC mismatch\",0x01:\"Invalid command/payload\"} with string fallback; add tests: firmware Unity for PLAY/STOP/BRIGHTNESS/GAMMA payload/validation, Rust tokio tests for CONTROL payload packing, React tests for slider clamps; document CONTROL and error taxonomy tables in docs/protocol/source-of-truth.md with examples and file references.",
			"reasoning": "Cross-language updates (C, Rust, TS/React), protocol doc changes, validation logic, and multi-layer tests. Firmware currently uses a literal case 0x11 and lacks range checks; Studio UI clamps are present but require label/semantics confirmation; error mapping needs structured parsing. Integration breadth and regression risk make this high complexity."
		},
		{
			"taskId": 14,
			"taskTitle": "Confirm PUT_END CRC semantics and align app/firmware + tests",
			"complexityScore": 7,
			"recommendedSubtasks": 8,
			"expansionPrompt": "Clarify spec in firmware/components/network/include/protocol_parser.h that PUT_END (0x12) payload is empty; add comment above handle_put_end in firmware/components/network/protocol_parser.c documenting full-buffer CRC validation against PUT_BEGIN.crc32; add defensive rejection if frame.length != 0 returning ERR_INVALID_FRAME; confirm Studio uploader in studio/src-tauri/src/lib.rs continues to send empty PUT_END and add a brief docstring; extend Rust unit/integration tests to assert PUT_END LEN==0, and simulate CRC-mismatch to verify error mapping; add firmware Unity tests for CRC mismatch on PUT_END and \"reject non-empty PUT_END\"; update docs/protocol/source-of-truth.md Upload section describing single-source CRC in PUT_BEGIN validated on PUT_END with file references; verify endianness and constants across sides via rg checks.",
			"reasoning": "Behavior is largely aligned already (Studio sends empty PUT_END, firmware validates CRC at end). Work focuses on making the contract explicit, adding defensive checks and tests across firmware and Studio, and updating documentation. Moderate scope with clear entry points and existing test scaffolds keeps complexity below task 13 but non-trivial."
		}
	]
}