{
  "version": 3,
  "sources": ["../../.pnpm/@tauri-apps+plugin-stronghold@2.3.0/node_modules/@tauri-apps/plugin-stronghold/dist-js/index.js"],
  "sourcesContent": ["import { invoke } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\nclass Location {\n    constructor(type, payload) {\n        this.type = type;\n        this.payload = payload;\n    }\n    static generic(vault, record) {\n        return new Location('Generic', {\n            vault,\n            record\n        });\n    }\n    static counter(vault, counter) {\n        return new Location('Counter', {\n            vault,\n            counter\n        });\n    }\n}\nclass ProcedureExecutor {\n    constructor(procedureArgs) {\n        this.procedureArgs = procedureArgs;\n    }\n    /**\n     * Generate a SLIP10 seed for the given location.\n     * @param outputLocation Location of the record where the seed will be stored.\n     * @param sizeBytes The size in bytes of the SLIP10 seed.\n     * @param hint The record hint.\n     * @returns\n     */\n    async generateSLIP10Seed(outputLocation, sizeBytes) {\n        return await invoke('plugin:stronghold|execute_procedure', {\n            ...this.procedureArgs,\n            procedure: {\n                type: 'SLIP10Generate',\n                payload: {\n                    output: outputLocation,\n                    sizeBytes\n                }\n            }\n        }).then((n) => Uint8Array.from(n));\n    }\n    /**\n     * Derive a SLIP10 private key using a seed or key.\n     * @param chain The chain path.\n     * @param source The source type, either 'Seed' or 'Key'.\n     * @param sourceLocation The source location, must be the `outputLocation` of a previous call to `generateSLIP10Seed` or `deriveSLIP10`.\n     * @param outputLocation Location of the record where the private key will be stored.\n     * @param hint The record hint.\n     * @returns\n     */\n    async deriveSLIP10(chain, source, sourceLocation, outputLocation) {\n        return await invoke('plugin:stronghold|execute_procedure', {\n            ...this.procedureArgs,\n            procedure: {\n                type: 'SLIP10Derive',\n                payload: {\n                    chain,\n                    input: {\n                        type: source,\n                        payload: sourceLocation\n                    },\n                    output: outputLocation\n                }\n            }\n        }).then((n) => Uint8Array.from(n));\n    }\n    /**\n     * Store a BIP39 mnemonic.\n     * @param mnemonic The mnemonic string.\n     * @param outputLocation The location of the record where the BIP39 mnemonic will be stored.\n     * @param passphrase The optional mnemonic passphrase.\n     * @param hint The record hint.\n     * @returns\n     */\n    async recoverBIP39(mnemonic, outputLocation, passphrase) {\n        return await invoke('plugin:stronghold|execute_procedure', {\n            ...this.procedureArgs,\n            procedure: {\n                type: 'BIP39Recover',\n                payload: {\n                    mnemonic,\n                    passphrase,\n                    output: outputLocation\n                }\n            }\n        }).then((n) => Uint8Array.from(n));\n    }\n    /**\n     * Generate a BIP39 seed.\n     * @param outputLocation The location of the record where the BIP39 seed will be stored.\n     * @param passphrase The optional mnemonic passphrase.\n     * @param hint The record hint.\n     * @returns\n     */\n    async generateBIP39(outputLocation, passphrase) {\n        return await invoke('plugin:stronghold|execute_procedure', {\n            ...this.procedureArgs,\n            procedure: {\n                type: 'BIP39Generate',\n                payload: {\n                    output: outputLocation,\n                    passphrase\n                }\n            }\n        }).then((n) => Uint8Array.from(n));\n    }\n    /**\n     * Gets the Ed25519 public key of a SLIP10 private key.\n     * @param privateKeyLocation The location of the private key. Must be the `outputLocation` of a previous call to `deriveSLIP10`.\n     * @returns A promise resolving to the public key hex string.\n     *\n     * @since 2.0.0\n     */\n    async getEd25519PublicKey(privateKeyLocation) {\n        return await invoke('plugin:stronghold|execute_procedure', {\n            ...this.procedureArgs,\n            procedure: {\n                type: 'PublicKey',\n                payload: {\n                    type: 'Ed25519',\n                    privateKey: privateKeyLocation\n                }\n            }\n        }).then((n) => Uint8Array.from(n));\n    }\n    /**\n     * Creates a Ed25519 signature from a private key.\n     * @param privateKeyLocation The location of the record where the private key is stored. Must be the `outputLocation` of a previous call to `deriveSLIP10`.\n     * @param msg The message to sign.\n     * @returns A promise resolving to the signature hex string.\n     *\n     * @since 2.0.0\n     */\n    async signEd25519(privateKeyLocation, msg) {\n        return await invoke('plugin:stronghold|execute_procedure', {\n            ...this.procedureArgs,\n            procedure: {\n                type: 'Ed25519Sign',\n                payload: {\n                    privateKey: privateKeyLocation,\n                    msg\n                }\n            }\n        }).then((n) => Uint8Array.from(n));\n    }\n}\nclass Client {\n    constructor(path, name) {\n        this.path = path;\n        this.name = name;\n    }\n    /**\n     * Get a vault by name.\n     * @param name\n     * @param flags\n     * @returns\n     */\n    getVault(name) {\n        return new Vault(this.path, this.name, name);\n    }\n    getStore() {\n        return new Store(this.path, this.name);\n    }\n}\nclass Store {\n    constructor(path, client) {\n        this.path = path;\n        this.client = client;\n    }\n    async get(key) {\n        return await invoke('plugin:stronghold|get_store_record', {\n            snapshotPath: this.path,\n            client: this.client,\n            key\n        }).then((v) => v && Uint8Array.from(v));\n    }\n    async insert(key, value, lifetime) {\n        await invoke('plugin:stronghold|save_store_record', {\n            snapshotPath: this.path,\n            client: this.client,\n            key,\n            value,\n            lifetime\n        });\n    }\n    async remove(key) {\n        return await invoke('plugin:stronghold|remove_store_record', {\n            snapshotPath: this.path,\n            client: this.client,\n            key\n        }).then((v) => v && Uint8Array.from(v));\n    }\n}\n/**\n * A key-value storage that allows create, update and delete operations.\n * It does not allow reading the data, so one of the procedures must be used to manipulate\n * the stored data, allowing secure storage of secrets.\n */\nclass Vault extends ProcedureExecutor {\n    constructor(path, client, name) {\n        super({\n            snapshotPath: path,\n            client,\n            vault: name\n        });\n        this.path = path;\n        this.client = client;\n        this.name = name;\n    }\n    /**\n     * Insert a record to this vault.\n     * @param location The record location.\n     * @param record  The record data.\n     * @param recordHint The record hint.\n     * @returns\n     */\n    async insert(recordPath, secret) {\n        await invoke('plugin:stronghold|save_secret', {\n            snapshotPath: this.path,\n            client: this.client,\n            vault: this.name,\n            recordPath,\n            secret\n        });\n    }\n    /**\n     * Remove a record from the vault.\n     * @param location The record location.\n     * @param gc Whether to additionally perform the gargage collection or not.\n     * @returns\n     */\n    async remove(location) {\n        await invoke('plugin:stronghold|remove_secret', {\n            snapshotPath: this.path,\n            client: this.client,\n            vault: this.name,\n            recordPath: location.payload.record\n        });\n    }\n}\n/**\n * A representation of an access to a stronghold.\n */\nclass Stronghold {\n    /**\n     * Initializes a stronghold.\n     * If the snapshot path located at `path` exists, the password must match.\n     * @param path\n     * @param password\n     */\n    constructor(path) {\n        this.path = path;\n    }\n    /**\n     * Load the snapshot if it exists (password must match), or start a fresh stronghold instance otherwise.\n     * @param password\n     * @returns\n     */\n    static async load(path, password) {\n        return await invoke('plugin:stronghold|initialize', {\n            snapshotPath: path,\n            password\n        }).then(() => new Stronghold(path));\n    }\n    /**\n     * Remove this instance from the cache.\n     */\n    async unload() {\n        await invoke('plugin:stronghold|destroy', {\n            snapshotPath: this.path\n        });\n    }\n    async loadClient(client) {\n        return await invoke('plugin:stronghold|load_client', {\n            snapshotPath: this.path,\n            client\n        }).then(() => new Client(this.path, client));\n    }\n    async createClient(client) {\n        return await invoke('plugin:stronghold|create_client', {\n            snapshotPath: this.path,\n            client\n        }).then(() => new Client(this.path, client));\n    }\n    /**\n     * Persists the stronghold state to the snapshot.\n     * @returns\n     */\n    async save() {\n        await invoke('plugin:stronghold|save', {\n            snapshotPath: this.path\n        });\n    }\n}\n\nexport { Client, Location, Store, Stronghold, Vault };\n"],
  "mappings": "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",
  "names": []
}
